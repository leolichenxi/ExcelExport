// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: BattleParam.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
/// <summary>Holder for reflection information generated from BattleParam.proto</summary>
public static partial class BattleParamReflection {

  #region Descriptor
  /// <summary>File descriptor for BattleParam.proto</summary>
  public static pbr::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbr::FileDescriptor descriptor;

  static BattleParamReflection() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        string.Concat(
          "ChFCYXR0bGVQYXJhbS5wcm90bxoSUG9zaXRpb24zSW50LnByb3RvIrUYCgtC",
          "YXR0bGVQYXJhbRIbChNCYXR0bGVTdGFydFdhaXRUaW1lGAEgASgFEhYKDkJh",
          "dHRsZU1hcFNpemVzGAIgAygFEjgKEERvZGdlRWZmZWN0TGltaXQYAyABKAsy",
          "Hi5CYXR0bGVQYXJhbS5Eb2RnZWVmZmVjdGxpbWl0XxI3Cg9Dcml0RWZmZWN0",
          "TGltaXQYBCABKAsyHi5CYXR0bGVQYXJhbS5Eb2RnZWVmZmVjdGxpbWl0XxI6",
          "ChJDcml0RGFtRWZmZWN0TGltaXQYBSABKAsyHi5CYXR0bGVQYXJhbS5Eb2Rn",
          "ZWVmZmVjdGxpbWl0XxI+ChZEZWZlbnNlUmF0ZUVmZmVjdExpbWl0GAYgASgL",
          "Mh4uQmF0dGxlUGFyYW0uRG9kZ2VlZmZlY3RsaW1pdF8SGQoRRGFtYWdlUmVk",
          "dWNlTGltaXQYByABKAUSNQoNQ29vbERvd25MaW1pdBgIIAEoCzIeLkJhdHRs",
          "ZVBhcmFtLkRvZGdlZWZmZWN0bGltaXRfEjwKEkVsZW1lbnRFZmZlY3RMaW1p",
          "dBgJIAEoCzIgLkJhdHRsZVBhcmFtLkVsZW1lbnRlZmZlY3RsaW1pdF8SGQoR",
          "RWxlbWVudEF0dGFja0Jhc2UYCiABKAESGgoSRWxlbWVudERlZmVuc2VCYXNl",
          "GAsgASgBEhkKEUVsZW1lbnRFZmZlY3RCYXNlGAwgASgFEj0KFURhbWFnZUNv",
          "cnJlY3Rpb25SYW5nZRgNIAEoCzIeLkJhdHRsZVBhcmFtLkRvZGdlZWZmZWN0",
          "bGltaXRfEhcKD0RvZGdlQ29ycmVjdGlvbhgOIAEoARIWCg5Dcml0Q29ycmVj",
          "dGlvbhgPIAEoARISCgpCbGNrRWZmZWN0GBAgASgFEjgKEEJsb2NrRWZmZWN0",
          "TGltaXQYESABKAsyHi5CYXR0bGVQYXJhbS5Eb2RnZWVmZmVjdGxpbWl0XxIa",
          "ChJIZXJvTWF4RW5lcmd5VmFsdWUYEiABKAUSGAoQSGVyb01heEVuZXJneU51",
          "bRgTIAEoBRIVCg1Mb3JkTWF4RW5lcmd5GBQgASgFEhYKDk1heEF0dGFja1Nw",
          "ZWVkGBUgASgBEhYKDkhlcm9Ta2lsbENvdW50GBYgASgFEhsKE01vbnN0ZXJX",
          "YWxrTW9kZVRpbWUYFyABKAUSGwoTTW9uc3RlckRyb3BNb2RlVGltZRgYIAEo",
          "BRIkCg1CYXR0bGVNYXBHcmlkGBkgASgLMg0uUG9zaXRpb24zSW50EhAKCEdy",
          "aWRTaXplGBogASgFEhAKCExvcmRHcmlkGBsgASgFEhUKDVNraWxsTW92ZVRp",
          "bWUYHCABKAUSFgoOU2tpbGxGbGFzaFRpbWUYHSABKAUSGAoQTW9uc3RlckRy",
          "b3BSYW5nZRgeIAEoBRIWCg5PZmZzZXREaXN0YW5jZRgfIAEoBRIYChBEcm9w",
          "SXRlbVN0YXlUaW1lGCAgASgFEhkKEUJhbm5lclN0YXlNYXh0aW1lGCEgASgF",
          "EhUKDUxvcmRNb3ZlU3BlZWQYIiABKAUSFQoNRHJvcEl0ZW1SYW5nZRgjIAEo",
          "BRIPCgdNYXhSb29tGCQgASgFEhgKEExvcmRIZWFsdGhGYWN0b3IYJSABKAUS",
          "GQoRUnVuZVJlZnJlc2hQcmljZXMYJiADKAUSGAoQSGVyb01heFJ1bmVDb3Vu",
          "dBgnIAEoBRIaChJNYXhTb3VsU3RhbXBEZW1hbmQYKCABKAUSHQoVU291bFN0",
          "YW1wRGVtYW5kRmFjdG9yGCkgASgBEhMKC0JhZ0NhcGFjaXR5GCogASgFEhUK",
          "DVJlc29sdmVGYWN0b3IYKyABKAUSGAoQU2tpbGxGYWRlT3V0VGltZRgsIAEo",
          "BRIYChBQdnBFbmVteUxvcmRHcmlkGC0gASgFEhUKDVB2cFNjZW5lQnVmZnMY",
          "LiADKAUSGwoTUHZwRmlyc3RIYW5kV2FpdGluZxgvIAEoBRIcChRQdnBTZWNv",
          "bmRIYW5kV2FpdGluZxgwIAEoBRIZChFQdnBTdGFydENvdW50RG93bhgxIAEo",
          "BRIYChBQdnBPdmVyQ291bnREb3duGDIgASgFEjAKDFNvdWxJbnRlcmVzdBgz",
          "IAEoCzIaLkJhdHRsZVBhcmFtLlNvdWxpbnRlcmVzdF8SGgoSQmF0dGxlSGVy",
          "b0RpZVZhbHVlGDQgASgFEhoKEkJhdHRsZU1heFRpbWVWYWx1ZRg1IAEoBRIW",
          "Cg5CYXR0bGVKdW1wVGltZRg2IAEoBRIeChZQcm9mZXNzaW9uVXBncmFkZUNv",
          "dW50GDcgASgFEhUKDUhhbmRDYXJkTGltaXQYOCABKAUSEwoLRm9yZ2V0Q29z",
          "dHMYOSADKAUSEQoJUHJheUNvc3RzGDogAygFEhoKEkNhcmRMZXZlbFVwTmVl",
          "ZE51bRg7IAEoBRIbChNDYXJkVXNlVG9EcmF3VW5pcXVlGDwgASgFEh0KFU9y",
          "aWdpbmFsSGFuZENhcmRMaW1pdBg9IAEoBRIjChtVbmlxdWVTa2lsbENhcmRM",
          "aW1pdENvdW50T1QYPiABKAUSIgoaRHJvcENvZWZmaWNpZW50SW5FbGl0ZVJv",
          "b20YPyABKAUSIQoZRHJvcENvZWZmaWNpZW50SW5Cb3NzUm9vbRhAIAEoBRIW",
          "Cg5IZXJvUmVib3JuVGltZRhBIAEoBRIeChZIZXJvUmVib3JuSHBDb3N0RmFj",
          "dG9yGEIgASgFEhsKE09yaWdpbmFsSGFuZENhcmROdW0YQyABKAUSIAoYQ2hh",
          "bGxlbmdlRmlyc3RIYW5kQ2hhbmNlGEQgASgFEhgKEFB2cENoYWxsZW5nZVRp",
          "bWUYRSABKAUSIAoYRmlyc3RIYW5kRW5lcmd5Q2FyZENvdW50GEYgASgFEiIK",
          "GlNlY29uZHRIYW5kRW5lcmd5Q2FyZENvdW50GEcgASgFEhgKEFB2cEZpcnN0",
          "SGFuZFRpbWUYSCABKAUSGQoRUHZwU2Vjb25kSGFuZFRpbWUYSSABKAUSFwoP",
          "TG9yZENhcmRTcGFjaW5nGEogASgFEhkKEUVuZXJneUNhcmRDaGVja1VwGEsg",
          "ASgFEh4KFlB2cE9yaWdpbmFsSGFuZENhcmROdW0YTCABKAUSGgoSQmF0dGxl",
          "U3BlZWRVcFJhdGVzGE0gAygBEhoKEkhhbmdVcEludGVydmFsVGltZRhOIAEo",
          "BRIeChZOZXh0V2F2ZUFwcGVhckludGVydmFsGE8gASgFEiAKBERpY2UYUCAB",
          "KAsyEi5CYXR0bGVQYXJhbS5EaWNlXxIkChxSZW1haW5zQ29tcG91bmRPcmln",
          "aW5hbENvdW50GFEgASgFEjYKD01hemVWYWx1ZUZhY3RvchhSIAEoCzIdLkJh",
          "dHRsZVBhcmFtLk1hemV2YWx1ZWZhY3Rvcl8SFgoOQmF0dGxlRGFzaFRpbWUY",
          "UyABKAUSGgoSQmF0dGxlRGFzaEJhY2tUaW1lGFQgASgFEhsKE0JhdHRsZVJv",
          "dW5kU2FmZVRpbWUYVSABKAUSGgoSQmF0dGxlV2FpdE5leHRUaW1lGFYgASgF",
          "EhcKD0JhdHRsZVJvdW5kVGltZRhXIAEoBRIZChFCYXR0bGVIaXRGbHlGb3Jj",
          "ZRhYIAEoBRIaChJCYXR0bGVIaXREb3duRm9yY2UYWSABKAUSHQoVQmF0dGxl",
          "SGl0Rmx5TWF4SGVpZ2h0GFogASgFEhUKDUJhdHRsZUdyYXZpdHkYWyABKAUS",
          "GgoSQmF0dGxlRmx5VXBHcmF2aXR5GFwgASgFEhwKFEJhdHRsZU5lYXJUb3BH",
          "cmF2aXR5GF0gASgFEhoKEkJhdHRsZU5lYXJUb3BTcGVlZBheIAEoBRotChFE",
          "b2RnZWVmZmVjdGxpbWl0XxILCgNNYXgYASABKAUSCwoDTWluGAIgASgFGi8K",
          "E0VsZW1lbnRlZmZlY3RsaW1pdF8SCwoDTWF4GAEgASgBEgsKA01pbhgCIAEo",
          "ARoxCg1Tb3VsaW50ZXJlc3RfEg4KBkZhY3RvchgBIAEoBRIQCghNYXhDb3Vu",
          "dBgCIAEoBRotCgVEaWNlXxIRCglEaWNlQ291bnQYASABKAUSEQoJRGljZVZh",
          "bHVlGAIgASgFGjMKEE1hemV2YWx1ZWZhY3Rvcl8SDwoHQXRrUmF0ZRgBIAEo",
          "ARIOCgZGYWN0b3IYAiABKAViBnByb3RvMw=="));
    descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
        new pbr::FileDescriptor[] { global::Position3IntReflection.Descriptor, },
        new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
          new pbr::GeneratedClrTypeInfo(typeof(global::BattleParam), global::BattleParam.Parser, new[]{ "BattleStartWaitTime", "BattleMapSizes", "DodgeEffectLimit", "CritEffectLimit", "CritDamEffectLimit", "DefenseRateEffectLimit", "DamageReduceLimit", "CoolDownLimit", "ElementEffectLimit", "ElementAttackBase", "ElementDefenseBase", "ElementEffectBase", "DamageCorrectionRange", "DodgeCorrection", "CritCorrection", "BlckEffect", "BlockEffectLimit", "HeroMaxEnergyValue", "HeroMaxEnergyNum", "LordMaxEnergy", "MaxAttackSpeed", "HeroSkillCount", "MonsterWalkModeTime", "MonsterDropModeTime", "BattleMapGrid", "GridSize", "LordGrid", "SkillMoveTime", "SkillFlashTime", "MonsterDropRange", "OffsetDistance", "DropItemStayTime", "BannerStayMaxtime", "LordMoveSpeed", "DropItemRange", "MaxRoom", "LordHealthFactor", "RuneRefreshPrices", "HeroMaxRuneCount", "MaxSoulStampDemand", "SoulStampDemandFactor", "BagCapacity", "ResolveFactor", "SkillFadeOutTime", "PvpEnemyLordGrid", "PvpSceneBuffs", "PvpFirstHandWaiting", "PvpSecondHandWaiting", "PvpStartCountDown", "PvpOverCountDown", "SoulInterest", "BattleHeroDieValue", "BattleMaxTimeValue", "BattleJumpTime", "ProfessionUpgradeCount", "HandCardLimit", "ForgetCosts", "PrayCosts", "CardLevelUpNeedNum", "CardUseToDrawUnique", "OriginalHandCardLimit", "UniqueSkillCardLimitCountOT", "DropCoefficientInEliteRoom", "DropCoefficientInBossRoom", "HeroRebornTime", "HeroRebornHpCostFactor", "OriginalHandCardNum", "ChallengeFirstHandChance", "PvpChallengeTime", "FirstHandEnergyCardCount", "SecondtHandEnergyCardCount", "PvpFirstHandTime", "PvpSecondHandTime", "LordCardSpacing", "EnergyCardCheckUp", "PvpOriginalHandCardNum", "BattleSpeedUpRates", "HangUpIntervalTime", "NextWaveAppearInterval", "Dice", "RemainsCompoundOriginalCount", "MazeValueFactor", "BattleDashTime", "BattleDashBackTime", "BattleRoundSafeTime", "BattleWaitNextTime", "BattleRoundTime", "BattleHitFlyForce", "BattleHitDownForce", "BattleHitFlyMaxHeight", "BattleGravity", "BattleFlyUpGravity", "BattleNearTopGravity", "BattleNearTopSpeed" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::BattleParam.Types.Dodgeeffectlimit_), global::BattleParam.Types.Dodgeeffectlimit_.Parser, new[]{ "Max", "Min" }, null, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::BattleParam.Types.Elementeffectlimit_), global::BattleParam.Types.Elementeffectlimit_.Parser, new[]{ "Max", "Min" }, null, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::BattleParam.Types.Soulinterest_), global::BattleParam.Types.Soulinterest_.Parser, new[]{ "Factor", "MaxCount" }, null, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::BattleParam.Types.Dice_), global::BattleParam.Types.Dice_.Parser, new[]{ "DiceCount", "DiceValue" }, null, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::BattleParam.Types.Mazevaluefactor_), global::BattleParam.Types.Mazevaluefactor_.Parser, new[]{ "AtkRate", "Factor" }, null, null, null, null)})
        }));
  }
  #endregion

}
#region Messages
public sealed partial class BattleParam : pb::IMessage<BattleParam>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    , pb::IBufferMessage
#endif
{
  private static readonly pb::MessageParser<BattleParam> _parser = new pb::MessageParser<BattleParam>(() => new BattleParam());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<BattleParam> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor {
    get { return global::BattleParamReflection.Descriptor.MessageTypes[0]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public BattleParam() {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public BattleParam(BattleParam other) : this() {
    battleStartWaitTime_ = other.battleStartWaitTime_;
    battleMapSizes_ = other.battleMapSizes_.Clone();
    dodgeEffectLimit_ = other.dodgeEffectLimit_ != null ? other.dodgeEffectLimit_.Clone() : null;
    critEffectLimit_ = other.critEffectLimit_ != null ? other.critEffectLimit_.Clone() : null;
    critDamEffectLimit_ = other.critDamEffectLimit_ != null ? other.critDamEffectLimit_.Clone() : null;
    defenseRateEffectLimit_ = other.defenseRateEffectLimit_ != null ? other.defenseRateEffectLimit_.Clone() : null;
    damageReduceLimit_ = other.damageReduceLimit_;
    coolDownLimit_ = other.coolDownLimit_ != null ? other.coolDownLimit_.Clone() : null;
    elementEffectLimit_ = other.elementEffectLimit_ != null ? other.elementEffectLimit_.Clone() : null;
    elementAttackBase_ = other.elementAttackBase_;
    elementDefenseBase_ = other.elementDefenseBase_;
    elementEffectBase_ = other.elementEffectBase_;
    damageCorrectionRange_ = other.damageCorrectionRange_ != null ? other.damageCorrectionRange_.Clone() : null;
    dodgeCorrection_ = other.dodgeCorrection_;
    critCorrection_ = other.critCorrection_;
    blckEffect_ = other.blckEffect_;
    blockEffectLimit_ = other.blockEffectLimit_ != null ? other.blockEffectLimit_.Clone() : null;
    heroMaxEnergyValue_ = other.heroMaxEnergyValue_;
    heroMaxEnergyNum_ = other.heroMaxEnergyNum_;
    lordMaxEnergy_ = other.lordMaxEnergy_;
    maxAttackSpeed_ = other.maxAttackSpeed_;
    heroSkillCount_ = other.heroSkillCount_;
    monsterWalkModeTime_ = other.monsterWalkModeTime_;
    monsterDropModeTime_ = other.monsterDropModeTime_;
    battleMapGrid_ = other.battleMapGrid_ != null ? other.battleMapGrid_.Clone() : null;
    gridSize_ = other.gridSize_;
    lordGrid_ = other.lordGrid_;
    skillMoveTime_ = other.skillMoveTime_;
    skillFlashTime_ = other.skillFlashTime_;
    monsterDropRange_ = other.monsterDropRange_;
    offsetDistance_ = other.offsetDistance_;
    dropItemStayTime_ = other.dropItemStayTime_;
    bannerStayMaxtime_ = other.bannerStayMaxtime_;
    lordMoveSpeed_ = other.lordMoveSpeed_;
    dropItemRange_ = other.dropItemRange_;
    maxRoom_ = other.maxRoom_;
    lordHealthFactor_ = other.lordHealthFactor_;
    runeRefreshPrices_ = other.runeRefreshPrices_.Clone();
    heroMaxRuneCount_ = other.heroMaxRuneCount_;
    maxSoulStampDemand_ = other.maxSoulStampDemand_;
    soulStampDemandFactor_ = other.soulStampDemandFactor_;
    bagCapacity_ = other.bagCapacity_;
    resolveFactor_ = other.resolveFactor_;
    skillFadeOutTime_ = other.skillFadeOutTime_;
    pvpEnemyLordGrid_ = other.pvpEnemyLordGrid_;
    pvpSceneBuffs_ = other.pvpSceneBuffs_.Clone();
    pvpFirstHandWaiting_ = other.pvpFirstHandWaiting_;
    pvpSecondHandWaiting_ = other.pvpSecondHandWaiting_;
    pvpStartCountDown_ = other.pvpStartCountDown_;
    pvpOverCountDown_ = other.pvpOverCountDown_;
    soulInterest_ = other.soulInterest_ != null ? other.soulInterest_.Clone() : null;
    battleHeroDieValue_ = other.battleHeroDieValue_;
    battleMaxTimeValue_ = other.battleMaxTimeValue_;
    battleJumpTime_ = other.battleJumpTime_;
    professionUpgradeCount_ = other.professionUpgradeCount_;
    handCardLimit_ = other.handCardLimit_;
    forgetCosts_ = other.forgetCosts_.Clone();
    prayCosts_ = other.prayCosts_.Clone();
    cardLevelUpNeedNum_ = other.cardLevelUpNeedNum_;
    cardUseToDrawUnique_ = other.cardUseToDrawUnique_;
    originalHandCardLimit_ = other.originalHandCardLimit_;
    uniqueSkillCardLimitCountOT_ = other.uniqueSkillCardLimitCountOT_;
    dropCoefficientInEliteRoom_ = other.dropCoefficientInEliteRoom_;
    dropCoefficientInBossRoom_ = other.dropCoefficientInBossRoom_;
    heroRebornTime_ = other.heroRebornTime_;
    heroRebornHpCostFactor_ = other.heroRebornHpCostFactor_;
    originalHandCardNum_ = other.originalHandCardNum_;
    challengeFirstHandChance_ = other.challengeFirstHandChance_;
    pvpChallengeTime_ = other.pvpChallengeTime_;
    firstHandEnergyCardCount_ = other.firstHandEnergyCardCount_;
    secondtHandEnergyCardCount_ = other.secondtHandEnergyCardCount_;
    pvpFirstHandTime_ = other.pvpFirstHandTime_;
    pvpSecondHandTime_ = other.pvpSecondHandTime_;
    lordCardSpacing_ = other.lordCardSpacing_;
    energyCardCheckUp_ = other.energyCardCheckUp_;
    pvpOriginalHandCardNum_ = other.pvpOriginalHandCardNum_;
    battleSpeedUpRates_ = other.battleSpeedUpRates_.Clone();
    hangUpIntervalTime_ = other.hangUpIntervalTime_;
    nextWaveAppearInterval_ = other.nextWaveAppearInterval_;
    dice_ = other.dice_ != null ? other.dice_.Clone() : null;
    remainsCompoundOriginalCount_ = other.remainsCompoundOriginalCount_;
    mazeValueFactor_ = other.mazeValueFactor_ != null ? other.mazeValueFactor_.Clone() : null;
    battleDashTime_ = other.battleDashTime_;
    battleDashBackTime_ = other.battleDashBackTime_;
    battleRoundSafeTime_ = other.battleRoundSafeTime_;
    battleWaitNextTime_ = other.battleWaitNextTime_;
    battleRoundTime_ = other.battleRoundTime_;
    battleHitFlyForce_ = other.battleHitFlyForce_;
    battleHitDownForce_ = other.battleHitDownForce_;
    battleHitFlyMaxHeight_ = other.battleHitFlyMaxHeight_;
    battleGravity_ = other.battleGravity_;
    battleFlyUpGravity_ = other.battleFlyUpGravity_;
    battleNearTopGravity_ = other.battleNearTopGravity_;
    battleNearTopSpeed_ = other.battleNearTopSpeed_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public BattleParam Clone() {
    return new BattleParam(this);
  }

  /// <summary>Field number for the "BattleStartWaitTime" field.</summary>
  public const int BattleStartWaitTimeFieldNumber = 1;
  private int battleStartWaitTime_;
  /// <summary>
  /// 战斗开始的等待时间
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleStartWaitTime {
    get { return battleStartWaitTime_; }
    set {
      battleStartWaitTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleMapSizes" field.</summary>
  public const int BattleMapSizesFieldNumber = 2;
  private static readonly pb::FieldCodec<int> _repeated_battleMapSizes_codec
      = pb::FieldCodec.ForInt32(18);
  private readonly pbc::RepeatedField<int> battleMapSizes_ = new pbc::RepeatedField<int>();
  /// <summary>
  /// 战斗场景的大小，第一项为宽，第二项为高(坐标原点为左下角)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<int> BattleMapSizes {
    get { return battleMapSizes_; }
  }

  /// <summary>Field number for the "DodgeEffectLimit" field.</summary>
  public const int DodgeEffectLimitFieldNumber = 3;
  private global::BattleParam.Types.Dodgeeffectlimit_ dodgeEffectLimit_;
  /// <summary>
  /// 闪避上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ DodgeEffectLimit {
    get { return dodgeEffectLimit_; }
    set {
      dodgeEffectLimit_ = value;
    }
  }

  /// <summary>Field number for the "CritEffectLimit" field.</summary>
  public const int CritEffectLimitFieldNumber = 4;
  private global::BattleParam.Types.Dodgeeffectlimit_ critEffectLimit_;
  /// <summary>
  /// 暴击上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ CritEffectLimit {
    get { return critEffectLimit_; }
    set {
      critEffectLimit_ = value;
    }
  }

  /// <summary>Field number for the "CritDamEffectLimit" field.</summary>
  public const int CritDamEffectLimitFieldNumber = 5;
  private global::BattleParam.Types.Dodgeeffectlimit_ critDamEffectLimit_;
  /// <summary>
  /// 暴击伤害上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ CritDamEffectLimit {
    get { return critDamEffectLimit_; }
    set {
      critDamEffectLimit_ = value;
    }
  }

  /// <summary>Field number for the "DefenseRateEffectLimit" field.</summary>
  public const int DefenseRateEffectLimitFieldNumber = 6;
  private global::BattleParam.Types.Dodgeeffectlimit_ defenseRateEffectLimit_;
  /// <summary>
  /// 伤害抗性上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ DefenseRateEffectLimit {
    get { return defenseRateEffectLimit_; }
    set {
      defenseRateEffectLimit_ = value;
    }
  }

  /// <summary>Field number for the "DamageReduceLimit" field.</summary>
  public const int DamageReduceLimitFieldNumber = 7;
  private int damageReduceLimit_;
  /// <summary>
  /// 伤害减免上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int DamageReduceLimit {
    get { return damageReduceLimit_; }
    set {
      damageReduceLimit_ = value;
    }
  }

  /// <summary>Field number for the "CoolDownLimit" field.</summary>
  public const int CoolDownLimitFieldNumber = 8;
  private global::BattleParam.Types.Dodgeeffectlimit_ coolDownLimit_;
  /// <summary>
  /// 攻击速度上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ CoolDownLimit {
    get { return coolDownLimit_; }
    set {
      coolDownLimit_ = value;
    }
  }

  /// <summary>Field number for the "ElementEffectLimit" field.</summary>
  public const int ElementEffectLimitFieldNumber = 9;
  private global::BattleParam.Types.Elementeffectlimit_ elementEffectLimit_;
  /// <summary>
  /// 克制强度上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Elementeffectlimit_ ElementEffectLimit {
    get { return elementEffectLimit_; }
    set {
      elementEffectLimit_ = value;
    }
  }

  /// <summary>Field number for the "ElementAttackBase" field.</summary>
  public const int ElementAttackBaseFieldNumber = 10;
  private double elementAttackBase_;
  /// <summary>
  /// 攻击基础克制强度
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double ElementAttackBase {
    get { return elementAttackBase_; }
    set {
      elementAttackBase_ = value;
    }
  }

  /// <summary>Field number for the "ElementDefenseBase" field.</summary>
  public const int ElementDefenseBaseFieldNumber = 11;
  private double elementDefenseBase_;
  /// <summary>
  /// 防御基础克制强度
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double ElementDefenseBase {
    get { return elementDefenseBase_; }
    set {
      elementDefenseBase_ = value;
    }
  }

  /// <summary>Field number for the "ElementEffectBase" field.</summary>
  public const int ElementEffectBaseFieldNumber = 12;
  private int elementEffectBase_;
  /// <summary>
  /// 默认克制强度
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int ElementEffectBase {
    get { return elementEffectBase_; }
    set {
      elementEffectBase_ = value;
    }
  }

  /// <summary>Field number for the "DamageCorrectionRange" field.</summary>
  public const int DamageCorrectionRangeFieldNumber = 13;
  private global::BattleParam.Types.Dodgeeffectlimit_ damageCorrectionRange_;
  /// <summary>
  /// 伤害随机范围
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ DamageCorrectionRange {
    get { return damageCorrectionRange_; }
    set {
      damageCorrectionRange_ = value;
    }
  }

  /// <summary>Field number for the "DodgeCorrection" field.</summary>
  public const int DodgeCorrectionFieldNumber = 14;
  private double dodgeCorrection_;
  /// <summary>
  /// 闪避修正系数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double DodgeCorrection {
    get { return dodgeCorrection_; }
    set {
      dodgeCorrection_ = value;
    }
  }

  /// <summary>Field number for the "CritCorrection" field.</summary>
  public const int CritCorrectionFieldNumber = 15;
  private double critCorrection_;
  /// <summary>
  /// 暴击修正系数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double CritCorrection {
    get { return critCorrection_; }
    set {
      critCorrection_ = value;
    }
  }

  /// <summary>Field number for the "BlckEffect" field.</summary>
  public const int BlckEffectFieldNumber = 16;
  private int blckEffect_;
  /// <summary>
  /// 格档效果
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BlckEffect {
    get { return blckEffect_; }
    set {
      blckEffect_ = value;
    }
  }

  /// <summary>Field number for the "BlockEffectLimit" field.</summary>
  public const int BlockEffectLimitFieldNumber = 17;
  private global::BattleParam.Types.Dodgeeffectlimit_ blockEffectLimit_;
  /// <summary>
  /// 格挡率上下限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dodgeeffectlimit_ BlockEffectLimit {
    get { return blockEffectLimit_; }
    set {
      blockEffectLimit_ = value;
    }
  }

  /// <summary>Field number for the "HeroMaxEnergyValue" field.</summary>
  public const int HeroMaxEnergyValueFieldNumber = 18;
  private int heroMaxEnergyValue_;
  /// <summary>
  /// 英雄能量值上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HeroMaxEnergyValue {
    get { return heroMaxEnergyValue_; }
    set {
      heroMaxEnergyValue_ = value;
    }
  }

  /// <summary>Field number for the "HeroMaxEnergyNum" field.</summary>
  public const int HeroMaxEnergyNumFieldNumber = 19;
  private int heroMaxEnergyNum_;
  /// <summary>
  /// 英雄能量技累计次数上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HeroMaxEnergyNum {
    get { return heroMaxEnergyNum_; }
    set {
      heroMaxEnergyNum_ = value;
    }
  }

  /// <summary>Field number for the "LordMaxEnergy" field.</summary>
  public const int LordMaxEnergyFieldNumber = 20;
  private int lordMaxEnergy_;
  /// <summary>
  /// 小姐姐能量上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int LordMaxEnergy {
    get { return lordMaxEnergy_; }
    set {
      lordMaxEnergy_ = value;
    }
  }

  /// <summary>Field number for the "MaxAttackSpeed" field.</summary>
  public const int MaxAttackSpeedFieldNumber = 21;
  private double maxAttackSpeed_;
  /// <summary>
  /// 最大攻击速度缩放比例。
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double MaxAttackSpeed {
    get { return maxAttackSpeed_; }
    set {
      maxAttackSpeed_ = value;
    }
  }

  /// <summary>Field number for the "HeroSkillCount" field.</summary>
  public const int HeroSkillCountFieldNumber = 22;
  private int heroSkillCount_;
  /// <summary>
  /// 英雄技能存储上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HeroSkillCount {
    get { return heroSkillCount_; }
    set {
      heroSkillCount_ = value;
    }
  }

  /// <summary>Field number for the "MonsterWalkModeTime" field.</summary>
  public const int MonsterWalkModeTimeFieldNumber = 23;
  private int monsterWalkModeTime_;
  /// <summary>
  /// 怪物行走入场时间(毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MonsterWalkModeTime {
    get { return monsterWalkModeTime_; }
    set {
      monsterWalkModeTime_ = value;
    }
  }

  /// <summary>Field number for the "MonsterDropModeTime" field.</summary>
  public const int MonsterDropModeTimeFieldNumber = 24;
  private int monsterDropModeTime_;
  /// <summary>
  /// 怪物掉落入场时间(毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MonsterDropModeTime {
    get { return monsterDropModeTime_; }
    set {
      monsterDropModeTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleMapGrid" field.</summary>
  public const int BattleMapGridFieldNumber = 25;
  private global::Position3Int battleMapGrid_;
  /// <summary>
  /// 战场格子数量，第一项为宽，第二项为高(坐标原点为左上角)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Position3Int BattleMapGrid {
    get { return battleMapGrid_; }
    set {
      battleMapGrid_ = value;
    }
  }

  /// <summary>Field number for the "GridSize" field.</summary>
  public const int GridSizeFieldNumber = 26;
  private int gridSize_;
  /// <summary>
  /// 格子尺寸，正方体直径
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int GridSize {
    get { return gridSize_; }
    set {
      gridSize_ = value;
    }
  }

  /// <summary>Field number for the "LordGrid" field.</summary>
  public const int LordGridFieldNumber = 27;
  private int lordGrid_;
  /// <summary>
  /// 小姐姐坐标
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int LordGrid {
    get { return lordGrid_; }
    set {
      lordGrid_ = value;
    }
  }

  /// <summary>Field number for the "SkillMoveTime" field.</summary>
  public const int SkillMoveTimeFieldNumber = 28;
  private int skillMoveTime_;
  /// <summary>
  /// 必杀位移时间（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int SkillMoveTime {
    get { return skillMoveTime_; }
    set {
      skillMoveTime_ = value;
    }
  }

  /// <summary>Field number for the "SkillFlashTime" field.</summary>
  public const int SkillFlashTimeFieldNumber = 29;
  private int skillFlashTime_;
  /// <summary>
  /// 必杀叮特效时间（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int SkillFlashTime {
    get { return skillFlashTime_; }
    set {
      skillFlashTime_ = value;
    }
  }

  /// <summary>Field number for the "MonsterDropRange" field.</summary>
  public const int MonsterDropRangeFieldNumber = 30;
  private int monsterDropRange_;
  /// <summary>
  /// 击杀魔物后掉落物掉落范围（以魔物的站立坐标为圆心）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MonsterDropRange {
    get { return monsterDropRange_; }
    set {
      monsterDropRange_ = value;
    }
  }

  /// <summary>Field number for the "OffsetDistance" field.</summary>
  public const int OffsetDistanceFieldNumber = 31;
  private int offsetDistance_;
  /// <summary>
  /// 掉落物反向偏移距离量
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int OffsetDistance {
    get { return offsetDistance_; }
    set {
      offsetDistance_ = value;
    }
  }

  /// <summary>Field number for the "DropItemStayTime" field.</summary>
  public const int DropItemStayTimeFieldNumber = 32;
  private int dropItemStayTime_;
  /// <summary>
  /// 掉落物品停留显示时间，单位是毫秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int DropItemStayTime {
    get { return dropItemStayTime_; }
    set {
      dropItemStayTime_ = value;
    }
  }

  /// <summary>Field number for the "BannerStayMaxtime" field.</summary>
  public const int BannerStayMaxtimeFieldNumber = 33;
  private int bannerStayMaxtime_;
  /// <summary>
  /// 获取记录面板停留最大时间，单位是毫秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BannerStayMaxtime {
    get { return bannerStayMaxtime_; }
    set {
      bannerStayMaxtime_ = value;
    }
  }

  /// <summary>Field number for the "LordMoveSpeed" field.</summary>
  public const int LordMoveSpeedFieldNumber = 34;
  private int lordMoveSpeed_;
  /// <summary>
  /// 小姐姐移动速度
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int LordMoveSpeed {
    get { return lordMoveSpeed_; }
    set {
      lordMoveSpeed_ = value;
    }
  }

  /// <summary>Field number for the "DropItemRange" field.</summary>
  public const int DropItemRangeFieldNumber = 35;
  private int dropItemRange_;
  /// <summary>
  /// 物品掉落范围，半径
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int DropItemRange {
    get { return dropItemRange_; }
    set {
      dropItemRange_ = value;
    }
  }

  /// <summary>Field number for the "MaxRoom" field.</summary>
  public const int MaxRoomFieldNumber = 36;
  private int maxRoom_;
  /// <summary>
  /// 副本每列最大房间数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MaxRoom {
    get { return maxRoom_; }
    set {
      maxRoom_ = value;
    }
  }

  /// <summary>Field number for the "LordHealthFactor" field.</summary>
  public const int LordHealthFactorFieldNumber = 37;
  private int lordHealthFactor_;
  /// <summary>
  /// 每一点领主生命值，回复英雄的百分比生命值。此值为万分比。
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int LordHealthFactor {
    get { return lordHealthFactor_; }
    set {
      lordHealthFactor_ = value;
    }
  }

  /// <summary>Field number for the "RuneRefreshPrices" field.</summary>
  public const int RuneRefreshPricesFieldNumber = 38;
  private static readonly pb::FieldCodec<int> _repeated_runeRefreshPrices_codec
      = pb::FieldCodec.ForInt32(306);
  private readonly pbc::RepeatedField<int> runeRefreshPrices_ = new pbc::RepeatedField<int>();
  /// <summary>
  /// RL中炼成阵刷新消耗规则
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<int> RuneRefreshPrices {
    get { return runeRefreshPrices_; }
  }

  /// <summary>Field number for the "HeroMaxRuneCount" field.</summary>
  public const int HeroMaxRuneCountFieldNumber = 39;
  private int heroMaxRuneCount_;
  /// <summary>
  /// 英雄最多可携带的符文数量
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HeroMaxRuneCount {
    get { return heroMaxRuneCount_; }
    set {
      heroMaxRuneCount_ = value;
    }
  }

  /// <summary>Field number for the "MaxSoulStampDemand" field.</summary>
  public const int MaxSoulStampDemandFieldNumber = 40;
  private int maxSoulStampDemand_;
  /// <summary>
  /// 最大炼成所需魂印数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MaxSoulStampDemand {
    get { return maxSoulStampDemand_; }
    set {
      maxSoulStampDemand_ = value;
    }
  }

  /// <summary>Field number for the "SoulStampDemandFactor" field.</summary>
  public const int SoulStampDemandFactorFieldNumber = 41;
  private double soulStampDemandFactor_;
  /// <summary>
  /// 炼成阵所需魂印数量，总等级*该系数，向下取整，即为每次炼成所需的魂印数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double SoulStampDemandFactor {
    get { return soulStampDemandFactor_; }
    set {
      soulStampDemandFactor_ = value;
    }
  }

  /// <summary>Field number for the "BagCapacity" field.</summary>
  public const int BagCapacityFieldNumber = 42;
  private int bagCapacity_;
  /// <summary>
  /// 战斗中，装备背包和魂印背包的数量上限。
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BagCapacity {
    get { return bagCapacity_; }
    set {
      bagCapacity_ = value;
    }
  }

  /// <summary>Field number for the "ResolveFactor" field.</summary>
  public const int ResolveFactorFieldNumber = 43;
  private int resolveFactor_;
  /// <summary>
  /// 战斗中，分解装备获得的魔魂。(万分比，向下取整)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int ResolveFactor {
    get { return resolveFactor_; }
    set {
      resolveFactor_ = value;
    }
  }

  /// <summary>Field number for the "SkillFadeOutTime" field.</summary>
  public const int SkillFadeOutTimeFieldNumber = 44;
  private int skillFadeOutTime_;
  /// <summary>
  /// 战斗中，释放必杀技后，淡出的时间，单位毫秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int SkillFadeOutTime {
    get { return skillFadeOutTime_; }
    set {
      skillFadeOutTime_ = value;
    }
  }

  /// <summary>Field number for the "PvpEnemyLordGrid" field.</summary>
  public const int PvpEnemyLordGridFieldNumber = 45;
  private int pvpEnemyLordGrid_;
  /// <summary>
  /// 对手小姐姐坐标
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpEnemyLordGrid {
    get { return pvpEnemyLordGrid_; }
    set {
      pvpEnemyLordGrid_ = value;
    }
  }

  /// <summary>Field number for the "PvpSceneBuffs" field.</summary>
  public const int PvpSceneBuffsFieldNumber = 46;
  private static readonly pb::FieldCodec<int> _repeated_pvpSceneBuffs_codec
      = pb::FieldCodec.ForInt32(370);
  private readonly pbc::RepeatedField<int> pvpSceneBuffs_ = new pbc::RepeatedField<int>();
  /// <summary>
  /// PVP战斗全场增强Buff，需填入BuffId
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<int> PvpSceneBuffs {
    get { return pvpSceneBuffs_; }
  }

  /// <summary>Field number for the "PvpFirstHandWaiting" field.</summary>
  public const int PvpFirstHandWaitingFieldNumber = 47;
  private int pvpFirstHandWaiting_;
  /// <summary>
  /// 先手技能等待时间，单位是秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpFirstHandWaiting {
    get { return pvpFirstHandWaiting_; }
    set {
      pvpFirstHandWaiting_ = value;
    }
  }

  /// <summary>Field number for the "PvpSecondHandWaiting" field.</summary>
  public const int PvpSecondHandWaitingFieldNumber = 48;
  private int pvpSecondHandWaiting_;
  /// <summary>
  /// 后手技能等待时间，单位是秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpSecondHandWaiting {
    get { return pvpSecondHandWaiting_; }
    set {
      pvpSecondHandWaiting_ = value;
    }
  }

  /// <summary>Field number for the "PvpStartCountDown" field.</summary>
  public const int PvpStartCountDownFieldNumber = 49;
  private int pvpStartCountDown_;
  /// <summary>
  /// 竞技战斗开始前倒计时，单位是秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpStartCountDown {
    get { return pvpStartCountDown_; }
    set {
      pvpStartCountDown_ = value;
    }
  }

  /// <summary>Field number for the "PvpOverCountDown" field.</summary>
  public const int PvpOverCountDownFieldNumber = 50;
  private int pvpOverCountDown_;
  /// <summary>
  /// 竞技战斗结束前倒计时，单位是秒
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpOverCountDown {
    get { return pvpOverCountDown_; }
    set {
      pvpOverCountDown_ = value;
    }
  }

  /// <summary>Field number for the "SoulInterest" field.</summary>
  public const int SoulInterestFieldNumber = 51;
  private global::BattleParam.Types.Soulinterest_ soulInterest_;
  /// <summary>
  /// 每轮魔魂的利息，当前魔魂多少，乘以万分比（向下取整），第二个数是最大值
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Soulinterest_ SoulInterest {
    get { return soulInterest_; }
    set {
      soulInterest_ = value;
    }
  }

  /// <summary>Field number for the "BattleHeroDieValue" field.</summary>
  public const int BattleHeroDieValueFieldNumber = 52;
  private int battleHeroDieValue_;
  /// <summary>
  /// 战斗最多死亡人数（含）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleHeroDieValue {
    get { return battleHeroDieValue_; }
    set {
      battleHeroDieValue_ = value;
    }
  }

  /// <summary>Field number for the "BattleMaxTimeValue" field.</summary>
  public const int BattleMaxTimeValueFieldNumber = 53;
  private int battleMaxTimeValue_;
  /// <summary>
  /// 战斗最大时间（含）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleMaxTimeValue {
    get { return battleMaxTimeValue_; }
    set {
      battleMaxTimeValue_ = value;
    }
  }

  /// <summary>Field number for the "BattleJumpTime" field.</summary>
  public const int BattleJumpTimeFieldNumber = 54;
  private int battleJumpTime_;
  /// <summary>
  /// 战斗移动跳跃时间（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleJumpTime {
    get { return battleJumpTime_; }
    set {
      battleJumpTime_ = value;
    }
  }

  /// <summary>Field number for the "ProfessionUpgradeCount" field.</summary>
  public const int ProfessionUpgradeCountFieldNumber = 55;
  private int professionUpgradeCount_;
  /// <summary>
  /// 一个上古残页房间，同时展示的商品数量。
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int ProfessionUpgradeCount {
    get { return professionUpgradeCount_; }
    set {
      professionUpgradeCount_ = value;
    }
  }

  /// <summary>Field number for the "HandCardLimit" field.</summary>
  public const int HandCardLimitFieldNumber = 56;
  private int handCardLimit_;
  /// <summary>
  /// 玩家战斗中手牌上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HandCardLimit {
    get { return handCardLimit_; }
    set {
      handCardLimit_ = value;
    }
  }

  /// <summary>Field number for the "ForgetCosts" field.</summary>
  public const int ForgetCostsFieldNumber = 57;
  private static readonly pb::FieldCodec<int> _repeated_forgetCosts_codec
      = pb::FieldCodec.ForInt32(458);
  private readonly pbc::RepeatedField<int> forgetCosts_ = new pbc::RepeatedField<int>();
  /// <summary>
  /// 遗忘操作消耗
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<int> ForgetCosts {
    get { return forgetCosts_; }
  }

  /// <summary>Field number for the "PrayCosts" field.</summary>
  public const int PrayCostsFieldNumber = 58;
  private static readonly pb::FieldCodec<int> _repeated_prayCosts_codec
      = pb::FieldCodec.ForInt32(466);
  private readonly pbc::RepeatedField<int> prayCosts_ = new pbc::RepeatedField<int>();
  /// <summary>
  /// 祈祷操作消耗
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<int> PrayCosts {
    get { return prayCosts_; }
  }

  /// <summary>Field number for the "CardLevelUpNeedNum" field.</summary>
  public const int CardLevelUpNeedNumFieldNumber = 59;
  private int cardLevelUpNeedNum_;
  /// <summary>
  /// X张同卡升级为1张高级卡，“X”
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CardLevelUpNeedNum {
    get { return cardLevelUpNeedNum_; }
    set {
      cardLevelUpNeedNum_ = value;
    }
  }

  /// <summary>Field number for the "CardUseToDrawUnique" field.</summary>
  public const int CardUseToDrawUniqueFieldNumber = 60;
  private int cardUseToDrawUnique_;
  /// <summary>
  /// 每使用5张基础卡，抽1张必杀卡（暂时屏蔽）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CardUseToDrawUnique {
    get { return cardUseToDrawUnique_; }
    set {
      cardUseToDrawUnique_ = value;
    }
  }

  /// <summary>Field number for the "OriginalHandCardLimit" field.</summary>
  public const int OriginalHandCardLimitFieldNumber = 61;
  private int originalHandCardLimit_;
  /// <summary>
  /// 玩家战斗中初始手牌上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int OriginalHandCardLimit {
    get { return originalHandCardLimit_; }
    set {
      originalHandCardLimit_ = value;
    }
  }

  /// <summary>Field number for the "UniqueSkillCardLimitCountOT" field.</summary>
  public const int UniqueSkillCardLimitCountOTFieldNumber = 62;
  private int uniqueSkillCardLimitCountOT_;
  /// <summary>
  /// 每轮发牌必杀卡数量上限
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int UniqueSkillCardLimitCountOT {
    get { return uniqueSkillCardLimitCountOT_; }
    set {
      uniqueSkillCardLimitCountOT_ = value;
    }
  }

  /// <summary>Field number for the "DropCoefficientInEliteRoom" field.</summary>
  public const int DropCoefficientInEliteRoomFieldNumber = 63;
  private int dropCoefficientInEliteRoom_;
  /// <summary>
  /// 精英房掉落翻倍系数（对应战斗地图配置表的MonsterValueBase的掉落字段）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int DropCoefficientInEliteRoom {
    get { return dropCoefficientInEliteRoom_; }
    set {
      dropCoefficientInEliteRoom_ = value;
    }
  }

  /// <summary>Field number for the "DropCoefficientInBossRoom" field.</summary>
  public const int DropCoefficientInBossRoomFieldNumber = 64;
  private int dropCoefficientInBossRoom_;
  /// <summary>
  /// BOSS房掉落翻倍系数（对应战斗地图配置表的MonsterValueBase的掉落字段）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int DropCoefficientInBossRoom {
    get { return dropCoefficientInBossRoom_; }
    set {
      dropCoefficientInBossRoom_ = value;
    }
  }

  /// <summary>Field number for the "HeroRebornTime" field.</summary>
  public const int HeroRebornTimeFieldNumber = 65;
  private int heroRebornTime_;
  /// <summary>
  /// 英雄死亡后，复活的时间，单位毫秒，用于在多层模式中
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HeroRebornTime {
    get { return heroRebornTime_; }
    set {
      heroRebornTime_ = value;
    }
  }

  /// <summary>Field number for the "HeroRebornHpCostFactor" field.</summary>
  public const int HeroRebornHpCostFactorFieldNumber = 66;
  private int heroRebornHpCostFactor_;
  /// <summary>
  /// 英雄死亡后，复活需要消耗的领主血量系数(仅限于迷宫中)，最终扣血量=英雄星级*该系数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HeroRebornHpCostFactor {
    get { return heroRebornHpCostFactor_; }
    set {
      heroRebornHpCostFactor_ = value;
    }
  }

  /// <summary>Field number for the "OriginalHandCardNum" field.</summary>
  public const int OriginalHandCardNumFieldNumber = 67;
  private int originalHandCardNum_;
  /// <summary>
  /// 玩家战斗中初始发牌数量（受HandCardLimit限制）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int OriginalHandCardNum {
    get { return originalHandCardNum_; }
    set {
      originalHandCardNum_ = value;
    }
  }

  /// <summary>Field number for the "ChallengeFirstHandChance" field.</summary>
  public const int ChallengeFirstHandChanceFieldNumber = 68;
  private int challengeFirstHandChance_;
  /// <summary>
  /// 挑战者先手概率（万分比）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int ChallengeFirstHandChance {
    get { return challengeFirstHandChance_; }
    set {
      challengeFirstHandChance_ = value;
    }
  }

  /// <summary>Field number for the "PvpChallengeTime" field.</summary>
  public const int PvpChallengeTimeFieldNumber = 69;
  private int pvpChallengeTime_;
  /// <summary>
  /// 天梯对战总时长
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpChallengeTime {
    get { return pvpChallengeTime_; }
    set {
      pvpChallengeTime_ = value;
    }
  }

  /// <summary>Field number for the "FirstHandEnergyCardCount" field.</summary>
  public const int FirstHandEnergyCardCountFieldNumber = 70;
  private int firstHandEnergyCardCount_;
  /// <summary>
  /// 天梯先手首次发牌必杀卡牌数量
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int FirstHandEnergyCardCount {
    get { return firstHandEnergyCardCount_; }
    set {
      firstHandEnergyCardCount_ = value;
    }
  }

  /// <summary>Field number for the "SecondtHandEnergyCardCount" field.</summary>
  public const int SecondtHandEnergyCardCountFieldNumber = 71;
  private int secondtHandEnergyCardCount_;
  /// <summary>
  /// 天梯后手首次发牌必杀卡牌数量
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int SecondtHandEnergyCardCount {
    get { return secondtHandEnergyCardCount_; }
    set {
      secondtHandEnergyCardCount_ = value;
    }
  }

  /// <summary>Field number for the "PvpFirstHandTime" field.</summary>
  public const int PvpFirstHandTimeFieldNumber = 72;
  private int pvpFirstHandTime_;
  /// <summary>
  /// 先手等待出手时间（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpFirstHandTime {
    get { return pvpFirstHandTime_; }
    set {
      pvpFirstHandTime_ = value;
    }
  }

  /// <summary>Field number for the "PvpSecondHandTime" field.</summary>
  public const int PvpSecondHandTimeFieldNumber = 73;
  private int pvpSecondHandTime_;
  /// <summary>
  /// 后手等待出手时间（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpSecondHandTime {
    get { return pvpSecondHandTime_; }
    set {
      pvpSecondHandTime_ = value;
    }
  }

  /// <summary>Field number for the "LordCardSpacing" field.</summary>
  public const int LordCardSpacingFieldNumber = 74;
  private int lordCardSpacing_;
  /// <summary>
  /// 领主卡牌使用间隔时间（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int LordCardSpacing {
    get { return lordCardSpacing_; }
    set {
      lordCardSpacing_ = value;
    }
  }

  /// <summary>Field number for the "EnergyCardCheckUp" field.</summary>
  public const int EnergyCardCheckUpFieldNumber = 75;
  private int energyCardCheckUp_;
  /// <summary>
  /// 必杀卡牌检查使用间隔（毫秒）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int EnergyCardCheckUp {
    get { return energyCardCheckUp_; }
    set {
      energyCardCheckUp_ = value;
    }
  }

  /// <summary>Field number for the "PvpOriginalHandCardNum" field.</summary>
  public const int PvpOriginalHandCardNumFieldNumber = 76;
  private int pvpOriginalHandCardNum_;
  /// <summary>
  /// PVP战斗玩家战斗中初始发牌数量（受HandCardLimit限制）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int PvpOriginalHandCardNum {
    get { return pvpOriginalHandCardNum_; }
    set {
      pvpOriginalHandCardNum_ = value;
    }
  }

  /// <summary>Field number for the "BattleSpeedUpRates" field.</summary>
  public const int BattleSpeedUpRatesFieldNumber = 77;
  private static readonly pb::FieldCodec<double> _repeated_battleSpeedUpRates_codec
      = pb::FieldCodec.ForDouble(618);
  private readonly pbc::RepeatedField<double> battleSpeedUpRates_ = new pbc::RepeatedField<double>();
  /// <summary>
  /// 所有战斗2倍速按钮实际读取值
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<double> BattleSpeedUpRates {
    get { return battleSpeedUpRates_; }
  }

  /// <summary>Field number for the "HangUpIntervalTime" field.</summary>
  public const int HangUpIntervalTimeFieldNumber = 78;
  private int hangUpIntervalTime_;
  /// <summary>
  /// 挂机流程间隔时间
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int HangUpIntervalTime {
    get { return hangUpIntervalTime_; }
    set {
      hangUpIntervalTime_ = value;
    }
  }

  /// <summary>Field number for the "NextWaveAppearInterval" field.</summary>
  public const int NextWaveAppearIntervalFieldNumber = 79;
  private int nextWaveAppearInterval_;
  /// <summary>
  /// 上一批次的怪物全部击杀完后，下一批次的怪物出现的时间间隔，单位(毫秒)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int NextWaveAppearInterval {
    get { return nextWaveAppearInterval_; }
    set {
      nextWaveAppearInterval_ = value;
    }
  }

  /// <summary>Field number for the "Dice" field.</summary>
  public const int DiceFieldNumber = 80;
  private global::BattleParam.Types.Dice_ dice_;
  /// <summary>
  /// 迷宫中玩家可选骰子数量的上限及迷宫中玩家骰子最大的面数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Dice_ Dice {
    get { return dice_; }
    set {
      dice_ = value;
    }
  }

  /// <summary>Field number for the "RemainsCompoundOriginalCount" field.</summary>
  public const int RemainsCompoundOriginalCountFieldNumber = 81;
  private int remainsCompoundOriginalCount_;
  /// <summary>
  /// 迷宫中玩家可合成遗物的初始次数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int RemainsCompoundOriginalCount {
    get { return remainsCompoundOriginalCount_; }
    set {
      remainsCompoundOriginalCount_ = value;
    }
  }

  /// <summary>Field number for the "MazeValueFactor" field.</summary>
  public const int MazeValueFactorFieldNumber = 82;
  private global::BattleParam.Types.Mazevaluefactor_ mazeValueFactor_;
  /// <summary>
  /// 迷宫动态难度的函数系数，AtkRate为攻击力计算时的倍速，Factor为计算函数中用的参数
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::BattleParam.Types.Mazevaluefactor_ MazeValueFactor {
    get { return mazeValueFactor_; }
    set {
      mazeValueFactor_ = value;
    }
  }

  /// <summary>Field number for the "BattleDashTime" field.</summary>
  public const int BattleDashTimeFieldNumber = 83;
  private int battleDashTime_;
  /// <summary>
  /// 近战战斗冲刺时间（Dash）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleDashTime {
    get { return battleDashTime_; }
    set {
      battleDashTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleDashBackTime" field.</summary>
  public const int BattleDashBackTimeFieldNumber = 84;
  private int battleDashBackTime_;
  /// <summary>
  /// 近战战斗冲刺返回时间（DashBack）
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleDashBackTime {
    get { return battleDashBackTime_; }
    set {
      battleDashBackTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleRoundSafeTime" field.</summary>
  public const int BattleRoundSafeTimeFieldNumber = 85;
  private int battleRoundSafeTime_;
  /// <summary>
  /// 如果有击飞和击倒 留出的安全表现时间
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleRoundSafeTime {
    get { return battleRoundSafeTime_; }
    set {
      battleRoundSafeTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleWaitNextTime" field.</summary>
  public const int BattleWaitNextTimeFieldNumber = 86;
  private int battleWaitNextTime_;
  /// <summary>
  /// 下个不是友军（如果不是友军，需要等待当年动作执行完毕），行动前，需要等待一个比较短暂的时间，该时间在全局配置表配置。作用为让摄像机回调到一个位置。
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleWaitNextTime {
    get { return battleWaitNextTime_; }
    set {
      battleWaitNextTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleRoundTime" field.</summary>
  public const int BattleRoundTimeFieldNumber = 87;
  private int battleRoundTime_;
  /// <summary>
  /// 行为重新开始等待时间
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleRoundTime {
    get { return battleRoundTime_; }
    set {
      battleRoundTime_ = value;
    }
  }

  /// <summary>Field number for the "BattleHitFlyForce" field.</summary>
  public const int BattleHitFlyForceFieldNumber = 88;
  private int battleHitFlyForce_;
  /// <summary>
  /// 击飞力
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleHitFlyForce {
    get { return battleHitFlyForce_; }
    set {
      battleHitFlyForce_ = value;
    }
  }

  /// <summary>Field number for the "BattleHitDownForce" field.</summary>
  public const int BattleHitDownForceFieldNumber = 89;
  private int battleHitDownForce_;
  /// <summary>
  /// 击倒力
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleHitDownForce {
    get { return battleHitDownForce_; }
    set {
      battleHitDownForce_ = value;
    }
  }

  /// <summary>Field number for the "BattleHitFlyMaxHeight" field.</summary>
  public const int BattleHitFlyMaxHeightFieldNumber = 90;
  private int battleHitFlyMaxHeight_;
  /// <summary>
  /// 击飞最大高度
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleHitFlyMaxHeight {
    get { return battleHitFlyMaxHeight_; }
    set {
      battleHitFlyMaxHeight_ = value;
    }
  }

  /// <summary>Field number for the "BattleGravity" field.</summary>
  public const int BattleGravityFieldNumber = 91;
  private int battleGravity_;
  /// <summary>
  /// 击飞下降重力
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleGravity {
    get { return battleGravity_; }
    set {
      battleGravity_ = value;
    }
  }

  /// <summary>Field number for the "BattleFlyUpGravity" field.</summary>
  public const int BattleFlyUpGravityFieldNumber = 92;
  private int battleFlyUpGravity_;
  /// <summary>
  /// 击飞上行重力
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleFlyUpGravity {
    get { return battleFlyUpGravity_; }
    set {
      battleFlyUpGravity_ = value;
    }
  }

  /// <summary>Field number for the "BattleNearTopGravity" field.</summary>
  public const int BattleNearTopGravityFieldNumber = 93;
  private int battleNearTopGravity_;
  /// <summary>
  /// 速度趋近顶部重力
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleNearTopGravity {
    get { return battleNearTopGravity_; }
    set {
      battleNearTopGravity_ = value;
    }
  }

  /// <summary>Field number for the "BattleNearTopSpeed" field.</summary>
  public const int BattleNearTopSpeedFieldNumber = 94;
  private int battleNearTopSpeed_;
  /// <summary>
  /// 速衰接近顶部速度判定
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int BattleNearTopSpeed {
    get { return battleNearTopSpeed_; }
    set {
      battleNearTopSpeed_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other) {
    return Equals(other as BattleParam);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(BattleParam other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (BattleStartWaitTime != other.BattleStartWaitTime) return false;
    if(!battleMapSizes_.Equals(other.battleMapSizes_)) return false;
    if (!object.Equals(DodgeEffectLimit, other.DodgeEffectLimit)) return false;
    if (!object.Equals(CritEffectLimit, other.CritEffectLimit)) return false;
    if (!object.Equals(CritDamEffectLimit, other.CritDamEffectLimit)) return false;
    if (!object.Equals(DefenseRateEffectLimit, other.DefenseRateEffectLimit)) return false;
    if (DamageReduceLimit != other.DamageReduceLimit) return false;
    if (!object.Equals(CoolDownLimit, other.CoolDownLimit)) return false;
    if (!object.Equals(ElementEffectLimit, other.ElementEffectLimit)) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ElementAttackBase, other.ElementAttackBase)) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ElementDefenseBase, other.ElementDefenseBase)) return false;
    if (ElementEffectBase != other.ElementEffectBase) return false;
    if (!object.Equals(DamageCorrectionRange, other.DamageCorrectionRange)) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(DodgeCorrection, other.DodgeCorrection)) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CritCorrection, other.CritCorrection)) return false;
    if (BlckEffect != other.BlckEffect) return false;
    if (!object.Equals(BlockEffectLimit, other.BlockEffectLimit)) return false;
    if (HeroMaxEnergyValue != other.HeroMaxEnergyValue) return false;
    if (HeroMaxEnergyNum != other.HeroMaxEnergyNum) return false;
    if (LordMaxEnergy != other.LordMaxEnergy) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MaxAttackSpeed, other.MaxAttackSpeed)) return false;
    if (HeroSkillCount != other.HeroSkillCount) return false;
    if (MonsterWalkModeTime != other.MonsterWalkModeTime) return false;
    if (MonsterDropModeTime != other.MonsterDropModeTime) return false;
    if (!object.Equals(BattleMapGrid, other.BattleMapGrid)) return false;
    if (GridSize != other.GridSize) return false;
    if (LordGrid != other.LordGrid) return false;
    if (SkillMoveTime != other.SkillMoveTime) return false;
    if (SkillFlashTime != other.SkillFlashTime) return false;
    if (MonsterDropRange != other.MonsterDropRange) return false;
    if (OffsetDistance != other.OffsetDistance) return false;
    if (DropItemStayTime != other.DropItemStayTime) return false;
    if (BannerStayMaxtime != other.BannerStayMaxtime) return false;
    if (LordMoveSpeed != other.LordMoveSpeed) return false;
    if (DropItemRange != other.DropItemRange) return false;
    if (MaxRoom != other.MaxRoom) return false;
    if (LordHealthFactor != other.LordHealthFactor) return false;
    if(!runeRefreshPrices_.Equals(other.runeRefreshPrices_)) return false;
    if (HeroMaxRuneCount != other.HeroMaxRuneCount) return false;
    if (MaxSoulStampDemand != other.MaxSoulStampDemand) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SoulStampDemandFactor, other.SoulStampDemandFactor)) return false;
    if (BagCapacity != other.BagCapacity) return false;
    if (ResolveFactor != other.ResolveFactor) return false;
    if (SkillFadeOutTime != other.SkillFadeOutTime) return false;
    if (PvpEnemyLordGrid != other.PvpEnemyLordGrid) return false;
    if(!pvpSceneBuffs_.Equals(other.pvpSceneBuffs_)) return false;
    if (PvpFirstHandWaiting != other.PvpFirstHandWaiting) return false;
    if (PvpSecondHandWaiting != other.PvpSecondHandWaiting) return false;
    if (PvpStartCountDown != other.PvpStartCountDown) return false;
    if (PvpOverCountDown != other.PvpOverCountDown) return false;
    if (!object.Equals(SoulInterest, other.SoulInterest)) return false;
    if (BattleHeroDieValue != other.BattleHeroDieValue) return false;
    if (BattleMaxTimeValue != other.BattleMaxTimeValue) return false;
    if (BattleJumpTime != other.BattleJumpTime) return false;
    if (ProfessionUpgradeCount != other.ProfessionUpgradeCount) return false;
    if (HandCardLimit != other.HandCardLimit) return false;
    if(!forgetCosts_.Equals(other.forgetCosts_)) return false;
    if(!prayCosts_.Equals(other.prayCosts_)) return false;
    if (CardLevelUpNeedNum != other.CardLevelUpNeedNum) return false;
    if (CardUseToDrawUnique != other.CardUseToDrawUnique) return false;
    if (OriginalHandCardLimit != other.OriginalHandCardLimit) return false;
    if (UniqueSkillCardLimitCountOT != other.UniqueSkillCardLimitCountOT) return false;
    if (DropCoefficientInEliteRoom != other.DropCoefficientInEliteRoom) return false;
    if (DropCoefficientInBossRoom != other.DropCoefficientInBossRoom) return false;
    if (HeroRebornTime != other.HeroRebornTime) return false;
    if (HeroRebornHpCostFactor != other.HeroRebornHpCostFactor) return false;
    if (OriginalHandCardNum != other.OriginalHandCardNum) return false;
    if (ChallengeFirstHandChance != other.ChallengeFirstHandChance) return false;
    if (PvpChallengeTime != other.PvpChallengeTime) return false;
    if (FirstHandEnergyCardCount != other.FirstHandEnergyCardCount) return false;
    if (SecondtHandEnergyCardCount != other.SecondtHandEnergyCardCount) return false;
    if (PvpFirstHandTime != other.PvpFirstHandTime) return false;
    if (PvpSecondHandTime != other.PvpSecondHandTime) return false;
    if (LordCardSpacing != other.LordCardSpacing) return false;
    if (EnergyCardCheckUp != other.EnergyCardCheckUp) return false;
    if (PvpOriginalHandCardNum != other.PvpOriginalHandCardNum) return false;
    if(!battleSpeedUpRates_.Equals(other.battleSpeedUpRates_)) return false;
    if (HangUpIntervalTime != other.HangUpIntervalTime) return false;
    if (NextWaveAppearInterval != other.NextWaveAppearInterval) return false;
    if (!object.Equals(Dice, other.Dice)) return false;
    if (RemainsCompoundOriginalCount != other.RemainsCompoundOriginalCount) return false;
    if (!object.Equals(MazeValueFactor, other.MazeValueFactor)) return false;
    if (BattleDashTime != other.BattleDashTime) return false;
    if (BattleDashBackTime != other.BattleDashBackTime) return false;
    if (BattleRoundSafeTime != other.BattleRoundSafeTime) return false;
    if (BattleWaitNextTime != other.BattleWaitNextTime) return false;
    if (BattleRoundTime != other.BattleRoundTime) return false;
    if (BattleHitFlyForce != other.BattleHitFlyForce) return false;
    if (BattleHitDownForce != other.BattleHitDownForce) return false;
    if (BattleHitFlyMaxHeight != other.BattleHitFlyMaxHeight) return false;
    if (BattleGravity != other.BattleGravity) return false;
    if (BattleFlyUpGravity != other.BattleFlyUpGravity) return false;
    if (BattleNearTopGravity != other.BattleNearTopGravity) return false;
    if (BattleNearTopSpeed != other.BattleNearTopSpeed) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode() {
    int hash = 1;
    if (BattleStartWaitTime != 0) hash ^= BattleStartWaitTime.GetHashCode();
    hash ^= battleMapSizes_.GetHashCode();
    if (dodgeEffectLimit_ != null) hash ^= DodgeEffectLimit.GetHashCode();
    if (critEffectLimit_ != null) hash ^= CritEffectLimit.GetHashCode();
    if (critDamEffectLimit_ != null) hash ^= CritDamEffectLimit.GetHashCode();
    if (defenseRateEffectLimit_ != null) hash ^= DefenseRateEffectLimit.GetHashCode();
    if (DamageReduceLimit != 0) hash ^= DamageReduceLimit.GetHashCode();
    if (coolDownLimit_ != null) hash ^= CoolDownLimit.GetHashCode();
    if (elementEffectLimit_ != null) hash ^= ElementEffectLimit.GetHashCode();
    if (ElementAttackBase != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ElementAttackBase);
    if (ElementDefenseBase != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ElementDefenseBase);
    if (ElementEffectBase != 0) hash ^= ElementEffectBase.GetHashCode();
    if (damageCorrectionRange_ != null) hash ^= DamageCorrectionRange.GetHashCode();
    if (DodgeCorrection != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(DodgeCorrection);
    if (CritCorrection != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CritCorrection);
    if (BlckEffect != 0) hash ^= BlckEffect.GetHashCode();
    if (blockEffectLimit_ != null) hash ^= BlockEffectLimit.GetHashCode();
    if (HeroMaxEnergyValue != 0) hash ^= HeroMaxEnergyValue.GetHashCode();
    if (HeroMaxEnergyNum != 0) hash ^= HeroMaxEnergyNum.GetHashCode();
    if (LordMaxEnergy != 0) hash ^= LordMaxEnergy.GetHashCode();
    if (MaxAttackSpeed != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MaxAttackSpeed);
    if (HeroSkillCount != 0) hash ^= HeroSkillCount.GetHashCode();
    if (MonsterWalkModeTime != 0) hash ^= MonsterWalkModeTime.GetHashCode();
    if (MonsterDropModeTime != 0) hash ^= MonsterDropModeTime.GetHashCode();
    if (battleMapGrid_ != null) hash ^= BattleMapGrid.GetHashCode();
    if (GridSize != 0) hash ^= GridSize.GetHashCode();
    if (LordGrid != 0) hash ^= LordGrid.GetHashCode();
    if (SkillMoveTime != 0) hash ^= SkillMoveTime.GetHashCode();
    if (SkillFlashTime != 0) hash ^= SkillFlashTime.GetHashCode();
    if (MonsterDropRange != 0) hash ^= MonsterDropRange.GetHashCode();
    if (OffsetDistance != 0) hash ^= OffsetDistance.GetHashCode();
    if (DropItemStayTime != 0) hash ^= DropItemStayTime.GetHashCode();
    if (BannerStayMaxtime != 0) hash ^= BannerStayMaxtime.GetHashCode();
    if (LordMoveSpeed != 0) hash ^= LordMoveSpeed.GetHashCode();
    if (DropItemRange != 0) hash ^= DropItemRange.GetHashCode();
    if (MaxRoom != 0) hash ^= MaxRoom.GetHashCode();
    if (LordHealthFactor != 0) hash ^= LordHealthFactor.GetHashCode();
    hash ^= runeRefreshPrices_.GetHashCode();
    if (HeroMaxRuneCount != 0) hash ^= HeroMaxRuneCount.GetHashCode();
    if (MaxSoulStampDemand != 0) hash ^= MaxSoulStampDemand.GetHashCode();
    if (SoulStampDemandFactor != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SoulStampDemandFactor);
    if (BagCapacity != 0) hash ^= BagCapacity.GetHashCode();
    if (ResolveFactor != 0) hash ^= ResolveFactor.GetHashCode();
    if (SkillFadeOutTime != 0) hash ^= SkillFadeOutTime.GetHashCode();
    if (PvpEnemyLordGrid != 0) hash ^= PvpEnemyLordGrid.GetHashCode();
    hash ^= pvpSceneBuffs_.GetHashCode();
    if (PvpFirstHandWaiting != 0) hash ^= PvpFirstHandWaiting.GetHashCode();
    if (PvpSecondHandWaiting != 0) hash ^= PvpSecondHandWaiting.GetHashCode();
    if (PvpStartCountDown != 0) hash ^= PvpStartCountDown.GetHashCode();
    if (PvpOverCountDown != 0) hash ^= PvpOverCountDown.GetHashCode();
    if (soulInterest_ != null) hash ^= SoulInterest.GetHashCode();
    if (BattleHeroDieValue != 0) hash ^= BattleHeroDieValue.GetHashCode();
    if (BattleMaxTimeValue != 0) hash ^= BattleMaxTimeValue.GetHashCode();
    if (BattleJumpTime != 0) hash ^= BattleJumpTime.GetHashCode();
    if (ProfessionUpgradeCount != 0) hash ^= ProfessionUpgradeCount.GetHashCode();
    if (HandCardLimit != 0) hash ^= HandCardLimit.GetHashCode();
    hash ^= forgetCosts_.GetHashCode();
    hash ^= prayCosts_.GetHashCode();
    if (CardLevelUpNeedNum != 0) hash ^= CardLevelUpNeedNum.GetHashCode();
    if (CardUseToDrawUnique != 0) hash ^= CardUseToDrawUnique.GetHashCode();
    if (OriginalHandCardLimit != 0) hash ^= OriginalHandCardLimit.GetHashCode();
    if (UniqueSkillCardLimitCountOT != 0) hash ^= UniqueSkillCardLimitCountOT.GetHashCode();
    if (DropCoefficientInEliteRoom != 0) hash ^= DropCoefficientInEliteRoom.GetHashCode();
    if (DropCoefficientInBossRoom != 0) hash ^= DropCoefficientInBossRoom.GetHashCode();
    if (HeroRebornTime != 0) hash ^= HeroRebornTime.GetHashCode();
    if (HeroRebornHpCostFactor != 0) hash ^= HeroRebornHpCostFactor.GetHashCode();
    if (OriginalHandCardNum != 0) hash ^= OriginalHandCardNum.GetHashCode();
    if (ChallengeFirstHandChance != 0) hash ^= ChallengeFirstHandChance.GetHashCode();
    if (PvpChallengeTime != 0) hash ^= PvpChallengeTime.GetHashCode();
    if (FirstHandEnergyCardCount != 0) hash ^= FirstHandEnergyCardCount.GetHashCode();
    if (SecondtHandEnergyCardCount != 0) hash ^= SecondtHandEnergyCardCount.GetHashCode();
    if (PvpFirstHandTime != 0) hash ^= PvpFirstHandTime.GetHashCode();
    if (PvpSecondHandTime != 0) hash ^= PvpSecondHandTime.GetHashCode();
    if (LordCardSpacing != 0) hash ^= LordCardSpacing.GetHashCode();
    if (EnergyCardCheckUp != 0) hash ^= EnergyCardCheckUp.GetHashCode();
    if (PvpOriginalHandCardNum != 0) hash ^= PvpOriginalHandCardNum.GetHashCode();
    hash ^= battleSpeedUpRates_.GetHashCode();
    if (HangUpIntervalTime != 0) hash ^= HangUpIntervalTime.GetHashCode();
    if (NextWaveAppearInterval != 0) hash ^= NextWaveAppearInterval.GetHashCode();
    if (dice_ != null) hash ^= Dice.GetHashCode();
    if (RemainsCompoundOriginalCount != 0) hash ^= RemainsCompoundOriginalCount.GetHashCode();
    if (mazeValueFactor_ != null) hash ^= MazeValueFactor.GetHashCode();
    if (BattleDashTime != 0) hash ^= BattleDashTime.GetHashCode();
    if (BattleDashBackTime != 0) hash ^= BattleDashBackTime.GetHashCode();
    if (BattleRoundSafeTime != 0) hash ^= BattleRoundSafeTime.GetHashCode();
    if (BattleWaitNextTime != 0) hash ^= BattleWaitNextTime.GetHashCode();
    if (BattleRoundTime != 0) hash ^= BattleRoundTime.GetHashCode();
    if (BattleHitFlyForce != 0) hash ^= BattleHitFlyForce.GetHashCode();
    if (BattleHitDownForce != 0) hash ^= BattleHitDownForce.GetHashCode();
    if (BattleHitFlyMaxHeight != 0) hash ^= BattleHitFlyMaxHeight.GetHashCode();
    if (BattleGravity != 0) hash ^= BattleGravity.GetHashCode();
    if (BattleFlyUpGravity != 0) hash ^= BattleFlyUpGravity.GetHashCode();
    if (BattleNearTopGravity != 0) hash ^= BattleNearTopGravity.GetHashCode();
    if (BattleNearTopSpeed != 0) hash ^= BattleNearTopSpeed.GetHashCode();
    if (_unknownFields != null) {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString() {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output) {
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    output.WriteRawMessage(this);
  #else
    if (BattleStartWaitTime != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(BattleStartWaitTime);
    }
    battleMapSizes_.WriteTo(output, _repeated_battleMapSizes_codec);
    if (dodgeEffectLimit_ != null) {
      output.WriteRawTag(26);
      output.WriteMessage(DodgeEffectLimit);
    }
    if (critEffectLimit_ != null) {
      output.WriteRawTag(34);
      output.WriteMessage(CritEffectLimit);
    }
    if (critDamEffectLimit_ != null) {
      output.WriteRawTag(42);
      output.WriteMessage(CritDamEffectLimit);
    }
    if (defenseRateEffectLimit_ != null) {
      output.WriteRawTag(50);
      output.WriteMessage(DefenseRateEffectLimit);
    }
    if (DamageReduceLimit != 0) {
      output.WriteRawTag(56);
      output.WriteInt32(DamageReduceLimit);
    }
    if (coolDownLimit_ != null) {
      output.WriteRawTag(66);
      output.WriteMessage(CoolDownLimit);
    }
    if (elementEffectLimit_ != null) {
      output.WriteRawTag(74);
      output.WriteMessage(ElementEffectLimit);
    }
    if (ElementAttackBase != 0D) {
      output.WriteRawTag(81);
      output.WriteDouble(ElementAttackBase);
    }
    if (ElementDefenseBase != 0D) {
      output.WriteRawTag(89);
      output.WriteDouble(ElementDefenseBase);
    }
    if (ElementEffectBase != 0) {
      output.WriteRawTag(96);
      output.WriteInt32(ElementEffectBase);
    }
    if (damageCorrectionRange_ != null) {
      output.WriteRawTag(106);
      output.WriteMessage(DamageCorrectionRange);
    }
    if (DodgeCorrection != 0D) {
      output.WriteRawTag(113);
      output.WriteDouble(DodgeCorrection);
    }
    if (CritCorrection != 0D) {
      output.WriteRawTag(121);
      output.WriteDouble(CritCorrection);
    }
    if (BlckEffect != 0) {
      output.WriteRawTag(128, 1);
      output.WriteInt32(BlckEffect);
    }
    if (blockEffectLimit_ != null) {
      output.WriteRawTag(138, 1);
      output.WriteMessage(BlockEffectLimit);
    }
    if (HeroMaxEnergyValue != 0) {
      output.WriteRawTag(144, 1);
      output.WriteInt32(HeroMaxEnergyValue);
    }
    if (HeroMaxEnergyNum != 0) {
      output.WriteRawTag(152, 1);
      output.WriteInt32(HeroMaxEnergyNum);
    }
    if (LordMaxEnergy != 0) {
      output.WriteRawTag(160, 1);
      output.WriteInt32(LordMaxEnergy);
    }
    if (MaxAttackSpeed != 0D) {
      output.WriteRawTag(169, 1);
      output.WriteDouble(MaxAttackSpeed);
    }
    if (HeroSkillCount != 0) {
      output.WriteRawTag(176, 1);
      output.WriteInt32(HeroSkillCount);
    }
    if (MonsterWalkModeTime != 0) {
      output.WriteRawTag(184, 1);
      output.WriteInt32(MonsterWalkModeTime);
    }
    if (MonsterDropModeTime != 0) {
      output.WriteRawTag(192, 1);
      output.WriteInt32(MonsterDropModeTime);
    }
    if (battleMapGrid_ != null) {
      output.WriteRawTag(202, 1);
      output.WriteMessage(BattleMapGrid);
    }
    if (GridSize != 0) {
      output.WriteRawTag(208, 1);
      output.WriteInt32(GridSize);
    }
    if (LordGrid != 0) {
      output.WriteRawTag(216, 1);
      output.WriteInt32(LordGrid);
    }
    if (SkillMoveTime != 0) {
      output.WriteRawTag(224, 1);
      output.WriteInt32(SkillMoveTime);
    }
    if (SkillFlashTime != 0) {
      output.WriteRawTag(232, 1);
      output.WriteInt32(SkillFlashTime);
    }
    if (MonsterDropRange != 0) {
      output.WriteRawTag(240, 1);
      output.WriteInt32(MonsterDropRange);
    }
    if (OffsetDistance != 0) {
      output.WriteRawTag(248, 1);
      output.WriteInt32(OffsetDistance);
    }
    if (DropItemStayTime != 0) {
      output.WriteRawTag(128, 2);
      output.WriteInt32(DropItemStayTime);
    }
    if (BannerStayMaxtime != 0) {
      output.WriteRawTag(136, 2);
      output.WriteInt32(BannerStayMaxtime);
    }
    if (LordMoveSpeed != 0) {
      output.WriteRawTag(144, 2);
      output.WriteInt32(LordMoveSpeed);
    }
    if (DropItemRange != 0) {
      output.WriteRawTag(152, 2);
      output.WriteInt32(DropItemRange);
    }
    if (MaxRoom != 0) {
      output.WriteRawTag(160, 2);
      output.WriteInt32(MaxRoom);
    }
    if (LordHealthFactor != 0) {
      output.WriteRawTag(168, 2);
      output.WriteInt32(LordHealthFactor);
    }
    runeRefreshPrices_.WriteTo(output, _repeated_runeRefreshPrices_codec);
    if (HeroMaxRuneCount != 0) {
      output.WriteRawTag(184, 2);
      output.WriteInt32(HeroMaxRuneCount);
    }
    if (MaxSoulStampDemand != 0) {
      output.WriteRawTag(192, 2);
      output.WriteInt32(MaxSoulStampDemand);
    }
    if (SoulStampDemandFactor != 0D) {
      output.WriteRawTag(201, 2);
      output.WriteDouble(SoulStampDemandFactor);
    }
    if (BagCapacity != 0) {
      output.WriteRawTag(208, 2);
      output.WriteInt32(BagCapacity);
    }
    if (ResolveFactor != 0) {
      output.WriteRawTag(216, 2);
      output.WriteInt32(ResolveFactor);
    }
    if (SkillFadeOutTime != 0) {
      output.WriteRawTag(224, 2);
      output.WriteInt32(SkillFadeOutTime);
    }
    if (PvpEnemyLordGrid != 0) {
      output.WriteRawTag(232, 2);
      output.WriteInt32(PvpEnemyLordGrid);
    }
    pvpSceneBuffs_.WriteTo(output, _repeated_pvpSceneBuffs_codec);
    if (PvpFirstHandWaiting != 0) {
      output.WriteRawTag(248, 2);
      output.WriteInt32(PvpFirstHandWaiting);
    }
    if (PvpSecondHandWaiting != 0) {
      output.WriteRawTag(128, 3);
      output.WriteInt32(PvpSecondHandWaiting);
    }
    if (PvpStartCountDown != 0) {
      output.WriteRawTag(136, 3);
      output.WriteInt32(PvpStartCountDown);
    }
    if (PvpOverCountDown != 0) {
      output.WriteRawTag(144, 3);
      output.WriteInt32(PvpOverCountDown);
    }
    if (soulInterest_ != null) {
      output.WriteRawTag(154, 3);
      output.WriteMessage(SoulInterest);
    }
    if (BattleHeroDieValue != 0) {
      output.WriteRawTag(160, 3);
      output.WriteInt32(BattleHeroDieValue);
    }
    if (BattleMaxTimeValue != 0) {
      output.WriteRawTag(168, 3);
      output.WriteInt32(BattleMaxTimeValue);
    }
    if (BattleJumpTime != 0) {
      output.WriteRawTag(176, 3);
      output.WriteInt32(BattleJumpTime);
    }
    if (ProfessionUpgradeCount != 0) {
      output.WriteRawTag(184, 3);
      output.WriteInt32(ProfessionUpgradeCount);
    }
    if (HandCardLimit != 0) {
      output.WriteRawTag(192, 3);
      output.WriteInt32(HandCardLimit);
    }
    forgetCosts_.WriteTo(output, _repeated_forgetCosts_codec);
    prayCosts_.WriteTo(output, _repeated_prayCosts_codec);
    if (CardLevelUpNeedNum != 0) {
      output.WriteRawTag(216, 3);
      output.WriteInt32(CardLevelUpNeedNum);
    }
    if (CardUseToDrawUnique != 0) {
      output.WriteRawTag(224, 3);
      output.WriteInt32(CardUseToDrawUnique);
    }
    if (OriginalHandCardLimit != 0) {
      output.WriteRawTag(232, 3);
      output.WriteInt32(OriginalHandCardLimit);
    }
    if (UniqueSkillCardLimitCountOT != 0) {
      output.WriteRawTag(240, 3);
      output.WriteInt32(UniqueSkillCardLimitCountOT);
    }
    if (DropCoefficientInEliteRoom != 0) {
      output.WriteRawTag(248, 3);
      output.WriteInt32(DropCoefficientInEliteRoom);
    }
    if (DropCoefficientInBossRoom != 0) {
      output.WriteRawTag(128, 4);
      output.WriteInt32(DropCoefficientInBossRoom);
    }
    if (HeroRebornTime != 0) {
      output.WriteRawTag(136, 4);
      output.WriteInt32(HeroRebornTime);
    }
    if (HeroRebornHpCostFactor != 0) {
      output.WriteRawTag(144, 4);
      output.WriteInt32(HeroRebornHpCostFactor);
    }
    if (OriginalHandCardNum != 0) {
      output.WriteRawTag(152, 4);
      output.WriteInt32(OriginalHandCardNum);
    }
    if (ChallengeFirstHandChance != 0) {
      output.WriteRawTag(160, 4);
      output.WriteInt32(ChallengeFirstHandChance);
    }
    if (PvpChallengeTime != 0) {
      output.WriteRawTag(168, 4);
      output.WriteInt32(PvpChallengeTime);
    }
    if (FirstHandEnergyCardCount != 0) {
      output.WriteRawTag(176, 4);
      output.WriteInt32(FirstHandEnergyCardCount);
    }
    if (SecondtHandEnergyCardCount != 0) {
      output.WriteRawTag(184, 4);
      output.WriteInt32(SecondtHandEnergyCardCount);
    }
    if (PvpFirstHandTime != 0) {
      output.WriteRawTag(192, 4);
      output.WriteInt32(PvpFirstHandTime);
    }
    if (PvpSecondHandTime != 0) {
      output.WriteRawTag(200, 4);
      output.WriteInt32(PvpSecondHandTime);
    }
    if (LordCardSpacing != 0) {
      output.WriteRawTag(208, 4);
      output.WriteInt32(LordCardSpacing);
    }
    if (EnergyCardCheckUp != 0) {
      output.WriteRawTag(216, 4);
      output.WriteInt32(EnergyCardCheckUp);
    }
    if (PvpOriginalHandCardNum != 0) {
      output.WriteRawTag(224, 4);
      output.WriteInt32(PvpOriginalHandCardNum);
    }
    battleSpeedUpRates_.WriteTo(output, _repeated_battleSpeedUpRates_codec);
    if (HangUpIntervalTime != 0) {
      output.WriteRawTag(240, 4);
      output.WriteInt32(HangUpIntervalTime);
    }
    if (NextWaveAppearInterval != 0) {
      output.WriteRawTag(248, 4);
      output.WriteInt32(NextWaveAppearInterval);
    }
    if (dice_ != null) {
      output.WriteRawTag(130, 5);
      output.WriteMessage(Dice);
    }
    if (RemainsCompoundOriginalCount != 0) {
      output.WriteRawTag(136, 5);
      output.WriteInt32(RemainsCompoundOriginalCount);
    }
    if (mazeValueFactor_ != null) {
      output.WriteRawTag(146, 5);
      output.WriteMessage(MazeValueFactor);
    }
    if (BattleDashTime != 0) {
      output.WriteRawTag(152, 5);
      output.WriteInt32(BattleDashTime);
    }
    if (BattleDashBackTime != 0) {
      output.WriteRawTag(160, 5);
      output.WriteInt32(BattleDashBackTime);
    }
    if (BattleRoundSafeTime != 0) {
      output.WriteRawTag(168, 5);
      output.WriteInt32(BattleRoundSafeTime);
    }
    if (BattleWaitNextTime != 0) {
      output.WriteRawTag(176, 5);
      output.WriteInt32(BattleWaitNextTime);
    }
    if (BattleRoundTime != 0) {
      output.WriteRawTag(184, 5);
      output.WriteInt32(BattleRoundTime);
    }
    if (BattleHitFlyForce != 0) {
      output.WriteRawTag(192, 5);
      output.WriteInt32(BattleHitFlyForce);
    }
    if (BattleHitDownForce != 0) {
      output.WriteRawTag(200, 5);
      output.WriteInt32(BattleHitDownForce);
    }
    if (BattleHitFlyMaxHeight != 0) {
      output.WriteRawTag(208, 5);
      output.WriteInt32(BattleHitFlyMaxHeight);
    }
    if (BattleGravity != 0) {
      output.WriteRawTag(216, 5);
      output.WriteInt32(BattleGravity);
    }
    if (BattleFlyUpGravity != 0) {
      output.WriteRawTag(224, 5);
      output.WriteInt32(BattleFlyUpGravity);
    }
    if (BattleNearTopGravity != 0) {
      output.WriteRawTag(232, 5);
      output.WriteInt32(BattleNearTopGravity);
    }
    if (BattleNearTopSpeed != 0) {
      output.WriteRawTag(240, 5);
      output.WriteInt32(BattleNearTopSpeed);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(output);
    }
  #endif
  }

  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
    if (BattleStartWaitTime != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(BattleStartWaitTime);
    }
    battleMapSizes_.WriteTo(ref output, _repeated_battleMapSizes_codec);
    if (dodgeEffectLimit_ != null) {
      output.WriteRawTag(26);
      output.WriteMessage(DodgeEffectLimit);
    }
    if (critEffectLimit_ != null) {
      output.WriteRawTag(34);
      output.WriteMessage(CritEffectLimit);
    }
    if (critDamEffectLimit_ != null) {
      output.WriteRawTag(42);
      output.WriteMessage(CritDamEffectLimit);
    }
    if (defenseRateEffectLimit_ != null) {
      output.WriteRawTag(50);
      output.WriteMessage(DefenseRateEffectLimit);
    }
    if (DamageReduceLimit != 0) {
      output.WriteRawTag(56);
      output.WriteInt32(DamageReduceLimit);
    }
    if (coolDownLimit_ != null) {
      output.WriteRawTag(66);
      output.WriteMessage(CoolDownLimit);
    }
    if (elementEffectLimit_ != null) {
      output.WriteRawTag(74);
      output.WriteMessage(ElementEffectLimit);
    }
    if (ElementAttackBase != 0D) {
      output.WriteRawTag(81);
      output.WriteDouble(ElementAttackBase);
    }
    if (ElementDefenseBase != 0D) {
      output.WriteRawTag(89);
      output.WriteDouble(ElementDefenseBase);
    }
    if (ElementEffectBase != 0) {
      output.WriteRawTag(96);
      output.WriteInt32(ElementEffectBase);
    }
    if (damageCorrectionRange_ != null) {
      output.WriteRawTag(106);
      output.WriteMessage(DamageCorrectionRange);
    }
    if (DodgeCorrection != 0D) {
      output.WriteRawTag(113);
      output.WriteDouble(DodgeCorrection);
    }
    if (CritCorrection != 0D) {
      output.WriteRawTag(121);
      output.WriteDouble(CritCorrection);
    }
    if (BlckEffect != 0) {
      output.WriteRawTag(128, 1);
      output.WriteInt32(BlckEffect);
    }
    if (blockEffectLimit_ != null) {
      output.WriteRawTag(138, 1);
      output.WriteMessage(BlockEffectLimit);
    }
    if (HeroMaxEnergyValue != 0) {
      output.WriteRawTag(144, 1);
      output.WriteInt32(HeroMaxEnergyValue);
    }
    if (HeroMaxEnergyNum != 0) {
      output.WriteRawTag(152, 1);
      output.WriteInt32(HeroMaxEnergyNum);
    }
    if (LordMaxEnergy != 0) {
      output.WriteRawTag(160, 1);
      output.WriteInt32(LordMaxEnergy);
    }
    if (MaxAttackSpeed != 0D) {
      output.WriteRawTag(169, 1);
      output.WriteDouble(MaxAttackSpeed);
    }
    if (HeroSkillCount != 0) {
      output.WriteRawTag(176, 1);
      output.WriteInt32(HeroSkillCount);
    }
    if (MonsterWalkModeTime != 0) {
      output.WriteRawTag(184, 1);
      output.WriteInt32(MonsterWalkModeTime);
    }
    if (MonsterDropModeTime != 0) {
      output.WriteRawTag(192, 1);
      output.WriteInt32(MonsterDropModeTime);
    }
    if (battleMapGrid_ != null) {
      output.WriteRawTag(202, 1);
      output.WriteMessage(BattleMapGrid);
    }
    if (GridSize != 0) {
      output.WriteRawTag(208, 1);
      output.WriteInt32(GridSize);
    }
    if (LordGrid != 0) {
      output.WriteRawTag(216, 1);
      output.WriteInt32(LordGrid);
    }
    if (SkillMoveTime != 0) {
      output.WriteRawTag(224, 1);
      output.WriteInt32(SkillMoveTime);
    }
    if (SkillFlashTime != 0) {
      output.WriteRawTag(232, 1);
      output.WriteInt32(SkillFlashTime);
    }
    if (MonsterDropRange != 0) {
      output.WriteRawTag(240, 1);
      output.WriteInt32(MonsterDropRange);
    }
    if (OffsetDistance != 0) {
      output.WriteRawTag(248, 1);
      output.WriteInt32(OffsetDistance);
    }
    if (DropItemStayTime != 0) {
      output.WriteRawTag(128, 2);
      output.WriteInt32(DropItemStayTime);
    }
    if (BannerStayMaxtime != 0) {
      output.WriteRawTag(136, 2);
      output.WriteInt32(BannerStayMaxtime);
    }
    if (LordMoveSpeed != 0) {
      output.WriteRawTag(144, 2);
      output.WriteInt32(LordMoveSpeed);
    }
    if (DropItemRange != 0) {
      output.WriteRawTag(152, 2);
      output.WriteInt32(DropItemRange);
    }
    if (MaxRoom != 0) {
      output.WriteRawTag(160, 2);
      output.WriteInt32(MaxRoom);
    }
    if (LordHealthFactor != 0) {
      output.WriteRawTag(168, 2);
      output.WriteInt32(LordHealthFactor);
    }
    runeRefreshPrices_.WriteTo(ref output, _repeated_runeRefreshPrices_codec);
    if (HeroMaxRuneCount != 0) {
      output.WriteRawTag(184, 2);
      output.WriteInt32(HeroMaxRuneCount);
    }
    if (MaxSoulStampDemand != 0) {
      output.WriteRawTag(192, 2);
      output.WriteInt32(MaxSoulStampDemand);
    }
    if (SoulStampDemandFactor != 0D) {
      output.WriteRawTag(201, 2);
      output.WriteDouble(SoulStampDemandFactor);
    }
    if (BagCapacity != 0) {
      output.WriteRawTag(208, 2);
      output.WriteInt32(BagCapacity);
    }
    if (ResolveFactor != 0) {
      output.WriteRawTag(216, 2);
      output.WriteInt32(ResolveFactor);
    }
    if (SkillFadeOutTime != 0) {
      output.WriteRawTag(224, 2);
      output.WriteInt32(SkillFadeOutTime);
    }
    if (PvpEnemyLordGrid != 0) {
      output.WriteRawTag(232, 2);
      output.WriteInt32(PvpEnemyLordGrid);
    }
    pvpSceneBuffs_.WriteTo(ref output, _repeated_pvpSceneBuffs_codec);
    if (PvpFirstHandWaiting != 0) {
      output.WriteRawTag(248, 2);
      output.WriteInt32(PvpFirstHandWaiting);
    }
    if (PvpSecondHandWaiting != 0) {
      output.WriteRawTag(128, 3);
      output.WriteInt32(PvpSecondHandWaiting);
    }
    if (PvpStartCountDown != 0) {
      output.WriteRawTag(136, 3);
      output.WriteInt32(PvpStartCountDown);
    }
    if (PvpOverCountDown != 0) {
      output.WriteRawTag(144, 3);
      output.WriteInt32(PvpOverCountDown);
    }
    if (soulInterest_ != null) {
      output.WriteRawTag(154, 3);
      output.WriteMessage(SoulInterest);
    }
    if (BattleHeroDieValue != 0) {
      output.WriteRawTag(160, 3);
      output.WriteInt32(BattleHeroDieValue);
    }
    if (BattleMaxTimeValue != 0) {
      output.WriteRawTag(168, 3);
      output.WriteInt32(BattleMaxTimeValue);
    }
    if (BattleJumpTime != 0) {
      output.WriteRawTag(176, 3);
      output.WriteInt32(BattleJumpTime);
    }
    if (ProfessionUpgradeCount != 0) {
      output.WriteRawTag(184, 3);
      output.WriteInt32(ProfessionUpgradeCount);
    }
    if (HandCardLimit != 0) {
      output.WriteRawTag(192, 3);
      output.WriteInt32(HandCardLimit);
    }
    forgetCosts_.WriteTo(ref output, _repeated_forgetCosts_codec);
    prayCosts_.WriteTo(ref output, _repeated_prayCosts_codec);
    if (CardLevelUpNeedNum != 0) {
      output.WriteRawTag(216, 3);
      output.WriteInt32(CardLevelUpNeedNum);
    }
    if (CardUseToDrawUnique != 0) {
      output.WriteRawTag(224, 3);
      output.WriteInt32(CardUseToDrawUnique);
    }
    if (OriginalHandCardLimit != 0) {
      output.WriteRawTag(232, 3);
      output.WriteInt32(OriginalHandCardLimit);
    }
    if (UniqueSkillCardLimitCountOT != 0) {
      output.WriteRawTag(240, 3);
      output.WriteInt32(UniqueSkillCardLimitCountOT);
    }
    if (DropCoefficientInEliteRoom != 0) {
      output.WriteRawTag(248, 3);
      output.WriteInt32(DropCoefficientInEliteRoom);
    }
    if (DropCoefficientInBossRoom != 0) {
      output.WriteRawTag(128, 4);
      output.WriteInt32(DropCoefficientInBossRoom);
    }
    if (HeroRebornTime != 0) {
      output.WriteRawTag(136, 4);
      output.WriteInt32(HeroRebornTime);
    }
    if (HeroRebornHpCostFactor != 0) {
      output.WriteRawTag(144, 4);
      output.WriteInt32(HeroRebornHpCostFactor);
    }
    if (OriginalHandCardNum != 0) {
      output.WriteRawTag(152, 4);
      output.WriteInt32(OriginalHandCardNum);
    }
    if (ChallengeFirstHandChance != 0) {
      output.WriteRawTag(160, 4);
      output.WriteInt32(ChallengeFirstHandChance);
    }
    if (PvpChallengeTime != 0) {
      output.WriteRawTag(168, 4);
      output.WriteInt32(PvpChallengeTime);
    }
    if (FirstHandEnergyCardCount != 0) {
      output.WriteRawTag(176, 4);
      output.WriteInt32(FirstHandEnergyCardCount);
    }
    if (SecondtHandEnergyCardCount != 0) {
      output.WriteRawTag(184, 4);
      output.WriteInt32(SecondtHandEnergyCardCount);
    }
    if (PvpFirstHandTime != 0) {
      output.WriteRawTag(192, 4);
      output.WriteInt32(PvpFirstHandTime);
    }
    if (PvpSecondHandTime != 0) {
      output.WriteRawTag(200, 4);
      output.WriteInt32(PvpSecondHandTime);
    }
    if (LordCardSpacing != 0) {
      output.WriteRawTag(208, 4);
      output.WriteInt32(LordCardSpacing);
    }
    if (EnergyCardCheckUp != 0) {
      output.WriteRawTag(216, 4);
      output.WriteInt32(EnergyCardCheckUp);
    }
    if (PvpOriginalHandCardNum != 0) {
      output.WriteRawTag(224, 4);
      output.WriteInt32(PvpOriginalHandCardNum);
    }
    battleSpeedUpRates_.WriteTo(ref output, _repeated_battleSpeedUpRates_codec);
    if (HangUpIntervalTime != 0) {
      output.WriteRawTag(240, 4);
      output.WriteInt32(HangUpIntervalTime);
    }
    if (NextWaveAppearInterval != 0) {
      output.WriteRawTag(248, 4);
      output.WriteInt32(NextWaveAppearInterval);
    }
    if (dice_ != null) {
      output.WriteRawTag(130, 5);
      output.WriteMessage(Dice);
    }
    if (RemainsCompoundOriginalCount != 0) {
      output.WriteRawTag(136, 5);
      output.WriteInt32(RemainsCompoundOriginalCount);
    }
    if (mazeValueFactor_ != null) {
      output.WriteRawTag(146, 5);
      output.WriteMessage(MazeValueFactor);
    }
    if (BattleDashTime != 0) {
      output.WriteRawTag(152, 5);
      output.WriteInt32(BattleDashTime);
    }
    if (BattleDashBackTime != 0) {
      output.WriteRawTag(160, 5);
      output.WriteInt32(BattleDashBackTime);
    }
    if (BattleRoundSafeTime != 0) {
      output.WriteRawTag(168, 5);
      output.WriteInt32(BattleRoundSafeTime);
    }
    if (BattleWaitNextTime != 0) {
      output.WriteRawTag(176, 5);
      output.WriteInt32(BattleWaitNextTime);
    }
    if (BattleRoundTime != 0) {
      output.WriteRawTag(184, 5);
      output.WriteInt32(BattleRoundTime);
    }
    if (BattleHitFlyForce != 0) {
      output.WriteRawTag(192, 5);
      output.WriteInt32(BattleHitFlyForce);
    }
    if (BattleHitDownForce != 0) {
      output.WriteRawTag(200, 5);
      output.WriteInt32(BattleHitDownForce);
    }
    if (BattleHitFlyMaxHeight != 0) {
      output.WriteRawTag(208, 5);
      output.WriteInt32(BattleHitFlyMaxHeight);
    }
    if (BattleGravity != 0) {
      output.WriteRawTag(216, 5);
      output.WriteInt32(BattleGravity);
    }
    if (BattleFlyUpGravity != 0) {
      output.WriteRawTag(224, 5);
      output.WriteInt32(BattleFlyUpGravity);
    }
    if (BattleNearTopGravity != 0) {
      output.WriteRawTag(232, 5);
      output.WriteInt32(BattleNearTopGravity);
    }
    if (BattleNearTopSpeed != 0) {
      output.WriteRawTag(240, 5);
      output.WriteInt32(BattleNearTopSpeed);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(ref output);
    }
  }
  #endif

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize() {
    int size = 0;
    if (BattleStartWaitTime != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(BattleStartWaitTime);
    }
    size += battleMapSizes_.CalculateSize(_repeated_battleMapSizes_codec);
    if (dodgeEffectLimit_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(DodgeEffectLimit);
    }
    if (critEffectLimit_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(CritEffectLimit);
    }
    if (critDamEffectLimit_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(CritDamEffectLimit);
    }
    if (defenseRateEffectLimit_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefenseRateEffectLimit);
    }
    if (DamageReduceLimit != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(DamageReduceLimit);
    }
    if (coolDownLimit_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(CoolDownLimit);
    }
    if (elementEffectLimit_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(ElementEffectLimit);
    }
    if (ElementAttackBase != 0D) {
      size += 1 + 8;
    }
    if (ElementDefenseBase != 0D) {
      size += 1 + 8;
    }
    if (ElementEffectBase != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(ElementEffectBase);
    }
    if (damageCorrectionRange_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(DamageCorrectionRange);
    }
    if (DodgeCorrection != 0D) {
      size += 1 + 8;
    }
    if (CritCorrection != 0D) {
      size += 1 + 8;
    }
    if (BlckEffect != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BlckEffect);
    }
    if (blockEffectLimit_ != null) {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(BlockEffectLimit);
    }
    if (HeroMaxEnergyValue != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HeroMaxEnergyValue);
    }
    if (HeroMaxEnergyNum != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HeroMaxEnergyNum);
    }
    if (LordMaxEnergy != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(LordMaxEnergy);
    }
    if (MaxAttackSpeed != 0D) {
      size += 2 + 8;
    }
    if (HeroSkillCount != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HeroSkillCount);
    }
    if (MonsterWalkModeTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(MonsterWalkModeTime);
    }
    if (MonsterDropModeTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(MonsterDropModeTime);
    }
    if (battleMapGrid_ != null) {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(BattleMapGrid);
    }
    if (GridSize != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(GridSize);
    }
    if (LordGrid != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(LordGrid);
    }
    if (SkillMoveTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(SkillMoveTime);
    }
    if (SkillFlashTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(SkillFlashTime);
    }
    if (MonsterDropRange != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(MonsterDropRange);
    }
    if (OffsetDistance != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(OffsetDistance);
    }
    if (DropItemStayTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(DropItemStayTime);
    }
    if (BannerStayMaxtime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BannerStayMaxtime);
    }
    if (LordMoveSpeed != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(LordMoveSpeed);
    }
    if (DropItemRange != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(DropItemRange);
    }
    if (MaxRoom != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxRoom);
    }
    if (LordHealthFactor != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(LordHealthFactor);
    }
    size += runeRefreshPrices_.CalculateSize(_repeated_runeRefreshPrices_codec);
    if (HeroMaxRuneCount != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HeroMaxRuneCount);
    }
    if (MaxSoulStampDemand != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxSoulStampDemand);
    }
    if (SoulStampDemandFactor != 0D) {
      size += 2 + 8;
    }
    if (BagCapacity != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BagCapacity);
    }
    if (ResolveFactor != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(ResolveFactor);
    }
    if (SkillFadeOutTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(SkillFadeOutTime);
    }
    if (PvpEnemyLordGrid != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpEnemyLordGrid);
    }
    size += pvpSceneBuffs_.CalculateSize(_repeated_pvpSceneBuffs_codec);
    if (PvpFirstHandWaiting != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpFirstHandWaiting);
    }
    if (PvpSecondHandWaiting != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpSecondHandWaiting);
    }
    if (PvpStartCountDown != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpStartCountDown);
    }
    if (PvpOverCountDown != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpOverCountDown);
    }
    if (soulInterest_ != null) {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(SoulInterest);
    }
    if (BattleHeroDieValue != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleHeroDieValue);
    }
    if (BattleMaxTimeValue != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleMaxTimeValue);
    }
    if (BattleJumpTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleJumpTime);
    }
    if (ProfessionUpgradeCount != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(ProfessionUpgradeCount);
    }
    if (HandCardLimit != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HandCardLimit);
    }
    size += forgetCosts_.CalculateSize(_repeated_forgetCosts_codec);
    size += prayCosts_.CalculateSize(_repeated_prayCosts_codec);
    if (CardLevelUpNeedNum != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(CardLevelUpNeedNum);
    }
    if (CardUseToDrawUnique != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(CardUseToDrawUnique);
    }
    if (OriginalHandCardLimit != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(OriginalHandCardLimit);
    }
    if (UniqueSkillCardLimitCountOT != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(UniqueSkillCardLimitCountOT);
    }
    if (DropCoefficientInEliteRoom != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(DropCoefficientInEliteRoom);
    }
    if (DropCoefficientInBossRoom != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(DropCoefficientInBossRoom);
    }
    if (HeroRebornTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HeroRebornTime);
    }
    if (HeroRebornHpCostFactor != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HeroRebornHpCostFactor);
    }
    if (OriginalHandCardNum != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(OriginalHandCardNum);
    }
    if (ChallengeFirstHandChance != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(ChallengeFirstHandChance);
    }
    if (PvpChallengeTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpChallengeTime);
    }
    if (FirstHandEnergyCardCount != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(FirstHandEnergyCardCount);
    }
    if (SecondtHandEnergyCardCount != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(SecondtHandEnergyCardCount);
    }
    if (PvpFirstHandTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpFirstHandTime);
    }
    if (PvpSecondHandTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpSecondHandTime);
    }
    if (LordCardSpacing != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(LordCardSpacing);
    }
    if (EnergyCardCheckUp != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(EnergyCardCheckUp);
    }
    if (PvpOriginalHandCardNum != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(PvpOriginalHandCardNum);
    }
    size += battleSpeedUpRates_.CalculateSize(_repeated_battleSpeedUpRates_codec);
    if (HangUpIntervalTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(HangUpIntervalTime);
    }
    if (NextWaveAppearInterval != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(NextWaveAppearInterval);
    }
    if (dice_ != null) {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(Dice);
    }
    if (RemainsCompoundOriginalCount != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(RemainsCompoundOriginalCount);
    }
    if (mazeValueFactor_ != null) {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(MazeValueFactor);
    }
    if (BattleDashTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleDashTime);
    }
    if (BattleDashBackTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleDashBackTime);
    }
    if (BattleRoundSafeTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleRoundSafeTime);
    }
    if (BattleWaitNextTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleWaitNextTime);
    }
    if (BattleRoundTime != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleRoundTime);
    }
    if (BattleHitFlyForce != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleHitFlyForce);
    }
    if (BattleHitDownForce != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleHitDownForce);
    }
    if (BattleHitFlyMaxHeight != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleHitFlyMaxHeight);
    }
    if (BattleGravity != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleGravity);
    }
    if (BattleFlyUpGravity != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleFlyUpGravity);
    }
    if (BattleNearTopGravity != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleNearTopGravity);
    }
    if (BattleNearTopSpeed != 0) {
      size += 2 + pb::CodedOutputStream.ComputeInt32Size(BattleNearTopSpeed);
    }
    if (_unknownFields != null) {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(BattleParam other) {
    if (other == null) {
      return;
    }
    if (other.BattleStartWaitTime != 0) {
      BattleStartWaitTime = other.BattleStartWaitTime;
    }
    battleMapSizes_.Add(other.battleMapSizes_);
    if (other.dodgeEffectLimit_ != null) {
      if (dodgeEffectLimit_ == null) {
        DodgeEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      DodgeEffectLimit.MergeFrom(other.DodgeEffectLimit);
    }
    if (other.critEffectLimit_ != null) {
      if (critEffectLimit_ == null) {
        CritEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      CritEffectLimit.MergeFrom(other.CritEffectLimit);
    }
    if (other.critDamEffectLimit_ != null) {
      if (critDamEffectLimit_ == null) {
        CritDamEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      CritDamEffectLimit.MergeFrom(other.CritDamEffectLimit);
    }
    if (other.defenseRateEffectLimit_ != null) {
      if (defenseRateEffectLimit_ == null) {
        DefenseRateEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      DefenseRateEffectLimit.MergeFrom(other.DefenseRateEffectLimit);
    }
    if (other.DamageReduceLimit != 0) {
      DamageReduceLimit = other.DamageReduceLimit;
    }
    if (other.coolDownLimit_ != null) {
      if (coolDownLimit_ == null) {
        CoolDownLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      CoolDownLimit.MergeFrom(other.CoolDownLimit);
    }
    if (other.elementEffectLimit_ != null) {
      if (elementEffectLimit_ == null) {
        ElementEffectLimit = new global::BattleParam.Types.Elementeffectlimit_();
      }
      ElementEffectLimit.MergeFrom(other.ElementEffectLimit);
    }
    if (other.ElementAttackBase != 0D) {
      ElementAttackBase = other.ElementAttackBase;
    }
    if (other.ElementDefenseBase != 0D) {
      ElementDefenseBase = other.ElementDefenseBase;
    }
    if (other.ElementEffectBase != 0) {
      ElementEffectBase = other.ElementEffectBase;
    }
    if (other.damageCorrectionRange_ != null) {
      if (damageCorrectionRange_ == null) {
        DamageCorrectionRange = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      DamageCorrectionRange.MergeFrom(other.DamageCorrectionRange);
    }
    if (other.DodgeCorrection != 0D) {
      DodgeCorrection = other.DodgeCorrection;
    }
    if (other.CritCorrection != 0D) {
      CritCorrection = other.CritCorrection;
    }
    if (other.BlckEffect != 0) {
      BlckEffect = other.BlckEffect;
    }
    if (other.blockEffectLimit_ != null) {
      if (blockEffectLimit_ == null) {
        BlockEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
      }
      BlockEffectLimit.MergeFrom(other.BlockEffectLimit);
    }
    if (other.HeroMaxEnergyValue != 0) {
      HeroMaxEnergyValue = other.HeroMaxEnergyValue;
    }
    if (other.HeroMaxEnergyNum != 0) {
      HeroMaxEnergyNum = other.HeroMaxEnergyNum;
    }
    if (other.LordMaxEnergy != 0) {
      LordMaxEnergy = other.LordMaxEnergy;
    }
    if (other.MaxAttackSpeed != 0D) {
      MaxAttackSpeed = other.MaxAttackSpeed;
    }
    if (other.HeroSkillCount != 0) {
      HeroSkillCount = other.HeroSkillCount;
    }
    if (other.MonsterWalkModeTime != 0) {
      MonsterWalkModeTime = other.MonsterWalkModeTime;
    }
    if (other.MonsterDropModeTime != 0) {
      MonsterDropModeTime = other.MonsterDropModeTime;
    }
    if (other.battleMapGrid_ != null) {
      if (battleMapGrid_ == null) {
        BattleMapGrid = new global::Position3Int();
      }
      BattleMapGrid.MergeFrom(other.BattleMapGrid);
    }
    if (other.GridSize != 0) {
      GridSize = other.GridSize;
    }
    if (other.LordGrid != 0) {
      LordGrid = other.LordGrid;
    }
    if (other.SkillMoveTime != 0) {
      SkillMoveTime = other.SkillMoveTime;
    }
    if (other.SkillFlashTime != 0) {
      SkillFlashTime = other.SkillFlashTime;
    }
    if (other.MonsterDropRange != 0) {
      MonsterDropRange = other.MonsterDropRange;
    }
    if (other.OffsetDistance != 0) {
      OffsetDistance = other.OffsetDistance;
    }
    if (other.DropItemStayTime != 0) {
      DropItemStayTime = other.DropItemStayTime;
    }
    if (other.BannerStayMaxtime != 0) {
      BannerStayMaxtime = other.BannerStayMaxtime;
    }
    if (other.LordMoveSpeed != 0) {
      LordMoveSpeed = other.LordMoveSpeed;
    }
    if (other.DropItemRange != 0) {
      DropItemRange = other.DropItemRange;
    }
    if (other.MaxRoom != 0) {
      MaxRoom = other.MaxRoom;
    }
    if (other.LordHealthFactor != 0) {
      LordHealthFactor = other.LordHealthFactor;
    }
    runeRefreshPrices_.Add(other.runeRefreshPrices_);
    if (other.HeroMaxRuneCount != 0) {
      HeroMaxRuneCount = other.HeroMaxRuneCount;
    }
    if (other.MaxSoulStampDemand != 0) {
      MaxSoulStampDemand = other.MaxSoulStampDemand;
    }
    if (other.SoulStampDemandFactor != 0D) {
      SoulStampDemandFactor = other.SoulStampDemandFactor;
    }
    if (other.BagCapacity != 0) {
      BagCapacity = other.BagCapacity;
    }
    if (other.ResolveFactor != 0) {
      ResolveFactor = other.ResolveFactor;
    }
    if (other.SkillFadeOutTime != 0) {
      SkillFadeOutTime = other.SkillFadeOutTime;
    }
    if (other.PvpEnemyLordGrid != 0) {
      PvpEnemyLordGrid = other.PvpEnemyLordGrid;
    }
    pvpSceneBuffs_.Add(other.pvpSceneBuffs_);
    if (other.PvpFirstHandWaiting != 0) {
      PvpFirstHandWaiting = other.PvpFirstHandWaiting;
    }
    if (other.PvpSecondHandWaiting != 0) {
      PvpSecondHandWaiting = other.PvpSecondHandWaiting;
    }
    if (other.PvpStartCountDown != 0) {
      PvpStartCountDown = other.PvpStartCountDown;
    }
    if (other.PvpOverCountDown != 0) {
      PvpOverCountDown = other.PvpOverCountDown;
    }
    if (other.soulInterest_ != null) {
      if (soulInterest_ == null) {
        SoulInterest = new global::BattleParam.Types.Soulinterest_();
      }
      SoulInterest.MergeFrom(other.SoulInterest);
    }
    if (other.BattleHeroDieValue != 0) {
      BattleHeroDieValue = other.BattleHeroDieValue;
    }
    if (other.BattleMaxTimeValue != 0) {
      BattleMaxTimeValue = other.BattleMaxTimeValue;
    }
    if (other.BattleJumpTime != 0) {
      BattleJumpTime = other.BattleJumpTime;
    }
    if (other.ProfessionUpgradeCount != 0) {
      ProfessionUpgradeCount = other.ProfessionUpgradeCount;
    }
    if (other.HandCardLimit != 0) {
      HandCardLimit = other.HandCardLimit;
    }
    forgetCosts_.Add(other.forgetCosts_);
    prayCosts_.Add(other.prayCosts_);
    if (other.CardLevelUpNeedNum != 0) {
      CardLevelUpNeedNum = other.CardLevelUpNeedNum;
    }
    if (other.CardUseToDrawUnique != 0) {
      CardUseToDrawUnique = other.CardUseToDrawUnique;
    }
    if (other.OriginalHandCardLimit != 0) {
      OriginalHandCardLimit = other.OriginalHandCardLimit;
    }
    if (other.UniqueSkillCardLimitCountOT != 0) {
      UniqueSkillCardLimitCountOT = other.UniqueSkillCardLimitCountOT;
    }
    if (other.DropCoefficientInEliteRoom != 0) {
      DropCoefficientInEliteRoom = other.DropCoefficientInEliteRoom;
    }
    if (other.DropCoefficientInBossRoom != 0) {
      DropCoefficientInBossRoom = other.DropCoefficientInBossRoom;
    }
    if (other.HeroRebornTime != 0) {
      HeroRebornTime = other.HeroRebornTime;
    }
    if (other.HeroRebornHpCostFactor != 0) {
      HeroRebornHpCostFactor = other.HeroRebornHpCostFactor;
    }
    if (other.OriginalHandCardNum != 0) {
      OriginalHandCardNum = other.OriginalHandCardNum;
    }
    if (other.ChallengeFirstHandChance != 0) {
      ChallengeFirstHandChance = other.ChallengeFirstHandChance;
    }
    if (other.PvpChallengeTime != 0) {
      PvpChallengeTime = other.PvpChallengeTime;
    }
    if (other.FirstHandEnergyCardCount != 0) {
      FirstHandEnergyCardCount = other.FirstHandEnergyCardCount;
    }
    if (other.SecondtHandEnergyCardCount != 0) {
      SecondtHandEnergyCardCount = other.SecondtHandEnergyCardCount;
    }
    if (other.PvpFirstHandTime != 0) {
      PvpFirstHandTime = other.PvpFirstHandTime;
    }
    if (other.PvpSecondHandTime != 0) {
      PvpSecondHandTime = other.PvpSecondHandTime;
    }
    if (other.LordCardSpacing != 0) {
      LordCardSpacing = other.LordCardSpacing;
    }
    if (other.EnergyCardCheckUp != 0) {
      EnergyCardCheckUp = other.EnergyCardCheckUp;
    }
    if (other.PvpOriginalHandCardNum != 0) {
      PvpOriginalHandCardNum = other.PvpOriginalHandCardNum;
    }
    battleSpeedUpRates_.Add(other.battleSpeedUpRates_);
    if (other.HangUpIntervalTime != 0) {
      HangUpIntervalTime = other.HangUpIntervalTime;
    }
    if (other.NextWaveAppearInterval != 0) {
      NextWaveAppearInterval = other.NextWaveAppearInterval;
    }
    if (other.dice_ != null) {
      if (dice_ == null) {
        Dice = new global::BattleParam.Types.Dice_();
      }
      Dice.MergeFrom(other.Dice);
    }
    if (other.RemainsCompoundOriginalCount != 0) {
      RemainsCompoundOriginalCount = other.RemainsCompoundOriginalCount;
    }
    if (other.mazeValueFactor_ != null) {
      if (mazeValueFactor_ == null) {
        MazeValueFactor = new global::BattleParam.Types.Mazevaluefactor_();
      }
      MazeValueFactor.MergeFrom(other.MazeValueFactor);
    }
    if (other.BattleDashTime != 0) {
      BattleDashTime = other.BattleDashTime;
    }
    if (other.BattleDashBackTime != 0) {
      BattleDashBackTime = other.BattleDashBackTime;
    }
    if (other.BattleRoundSafeTime != 0) {
      BattleRoundSafeTime = other.BattleRoundSafeTime;
    }
    if (other.BattleWaitNextTime != 0) {
      BattleWaitNextTime = other.BattleWaitNextTime;
    }
    if (other.BattleRoundTime != 0) {
      BattleRoundTime = other.BattleRoundTime;
    }
    if (other.BattleHitFlyForce != 0) {
      BattleHitFlyForce = other.BattleHitFlyForce;
    }
    if (other.BattleHitDownForce != 0) {
      BattleHitDownForce = other.BattleHitDownForce;
    }
    if (other.BattleHitFlyMaxHeight != 0) {
      BattleHitFlyMaxHeight = other.BattleHitFlyMaxHeight;
    }
    if (other.BattleGravity != 0) {
      BattleGravity = other.BattleGravity;
    }
    if (other.BattleFlyUpGravity != 0) {
      BattleFlyUpGravity = other.BattleFlyUpGravity;
    }
    if (other.BattleNearTopGravity != 0) {
      BattleNearTopGravity = other.BattleNearTopGravity;
    }
    if (other.BattleNearTopSpeed != 0) {
      BattleNearTopSpeed = other.BattleNearTopSpeed;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input) {
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    input.ReadRawMessage(this);
  #else
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8: {
          BattleStartWaitTime = input.ReadInt32();
          break;
        }
        case 18:
        case 16: {
          battleMapSizes_.AddEntriesFrom(input, _repeated_battleMapSizes_codec);
          break;
        }
        case 26: {
          if (dodgeEffectLimit_ == null) {
            DodgeEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(DodgeEffectLimit);
          break;
        }
        case 34: {
          if (critEffectLimit_ == null) {
            CritEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(CritEffectLimit);
          break;
        }
        case 42: {
          if (critDamEffectLimit_ == null) {
            CritDamEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(CritDamEffectLimit);
          break;
        }
        case 50: {
          if (defenseRateEffectLimit_ == null) {
            DefenseRateEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(DefenseRateEffectLimit);
          break;
        }
        case 56: {
          DamageReduceLimit = input.ReadInt32();
          break;
        }
        case 66: {
          if (coolDownLimit_ == null) {
            CoolDownLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(CoolDownLimit);
          break;
        }
        case 74: {
          if (elementEffectLimit_ == null) {
            ElementEffectLimit = new global::BattleParam.Types.Elementeffectlimit_();
          }
          input.ReadMessage(ElementEffectLimit);
          break;
        }
        case 81: {
          ElementAttackBase = input.ReadDouble();
          break;
        }
        case 89: {
          ElementDefenseBase = input.ReadDouble();
          break;
        }
        case 96: {
          ElementEffectBase = input.ReadInt32();
          break;
        }
        case 106: {
          if (damageCorrectionRange_ == null) {
            DamageCorrectionRange = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(DamageCorrectionRange);
          break;
        }
        case 113: {
          DodgeCorrection = input.ReadDouble();
          break;
        }
        case 121: {
          CritCorrection = input.ReadDouble();
          break;
        }
        case 128: {
          BlckEffect = input.ReadInt32();
          break;
        }
        case 138: {
          if (blockEffectLimit_ == null) {
            BlockEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(BlockEffectLimit);
          break;
        }
        case 144: {
          HeroMaxEnergyValue = input.ReadInt32();
          break;
        }
        case 152: {
          HeroMaxEnergyNum = input.ReadInt32();
          break;
        }
        case 160: {
          LordMaxEnergy = input.ReadInt32();
          break;
        }
        case 169: {
          MaxAttackSpeed = input.ReadDouble();
          break;
        }
        case 176: {
          HeroSkillCount = input.ReadInt32();
          break;
        }
        case 184: {
          MonsterWalkModeTime = input.ReadInt32();
          break;
        }
        case 192: {
          MonsterDropModeTime = input.ReadInt32();
          break;
        }
        case 202: {
          if (battleMapGrid_ == null) {
            BattleMapGrid = new global::Position3Int();
          }
          input.ReadMessage(BattleMapGrid);
          break;
        }
        case 208: {
          GridSize = input.ReadInt32();
          break;
        }
        case 216: {
          LordGrid = input.ReadInt32();
          break;
        }
        case 224: {
          SkillMoveTime = input.ReadInt32();
          break;
        }
        case 232: {
          SkillFlashTime = input.ReadInt32();
          break;
        }
        case 240: {
          MonsterDropRange = input.ReadInt32();
          break;
        }
        case 248: {
          OffsetDistance = input.ReadInt32();
          break;
        }
        case 256: {
          DropItemStayTime = input.ReadInt32();
          break;
        }
        case 264: {
          BannerStayMaxtime = input.ReadInt32();
          break;
        }
        case 272: {
          LordMoveSpeed = input.ReadInt32();
          break;
        }
        case 280: {
          DropItemRange = input.ReadInt32();
          break;
        }
        case 288: {
          MaxRoom = input.ReadInt32();
          break;
        }
        case 296: {
          LordHealthFactor = input.ReadInt32();
          break;
        }
        case 306:
        case 304: {
          runeRefreshPrices_.AddEntriesFrom(input, _repeated_runeRefreshPrices_codec);
          break;
        }
        case 312: {
          HeroMaxRuneCount = input.ReadInt32();
          break;
        }
        case 320: {
          MaxSoulStampDemand = input.ReadInt32();
          break;
        }
        case 329: {
          SoulStampDemandFactor = input.ReadDouble();
          break;
        }
        case 336: {
          BagCapacity = input.ReadInt32();
          break;
        }
        case 344: {
          ResolveFactor = input.ReadInt32();
          break;
        }
        case 352: {
          SkillFadeOutTime = input.ReadInt32();
          break;
        }
        case 360: {
          PvpEnemyLordGrid = input.ReadInt32();
          break;
        }
        case 370:
        case 368: {
          pvpSceneBuffs_.AddEntriesFrom(input, _repeated_pvpSceneBuffs_codec);
          break;
        }
        case 376: {
          PvpFirstHandWaiting = input.ReadInt32();
          break;
        }
        case 384: {
          PvpSecondHandWaiting = input.ReadInt32();
          break;
        }
        case 392: {
          PvpStartCountDown = input.ReadInt32();
          break;
        }
        case 400: {
          PvpOverCountDown = input.ReadInt32();
          break;
        }
        case 410: {
          if (soulInterest_ == null) {
            SoulInterest = new global::BattleParam.Types.Soulinterest_();
          }
          input.ReadMessage(SoulInterest);
          break;
        }
        case 416: {
          BattleHeroDieValue = input.ReadInt32();
          break;
        }
        case 424: {
          BattleMaxTimeValue = input.ReadInt32();
          break;
        }
        case 432: {
          BattleJumpTime = input.ReadInt32();
          break;
        }
        case 440: {
          ProfessionUpgradeCount = input.ReadInt32();
          break;
        }
        case 448: {
          HandCardLimit = input.ReadInt32();
          break;
        }
        case 458:
        case 456: {
          forgetCosts_.AddEntriesFrom(input, _repeated_forgetCosts_codec);
          break;
        }
        case 466:
        case 464: {
          prayCosts_.AddEntriesFrom(input, _repeated_prayCosts_codec);
          break;
        }
        case 472: {
          CardLevelUpNeedNum = input.ReadInt32();
          break;
        }
        case 480: {
          CardUseToDrawUnique = input.ReadInt32();
          break;
        }
        case 488: {
          OriginalHandCardLimit = input.ReadInt32();
          break;
        }
        case 496: {
          UniqueSkillCardLimitCountOT = input.ReadInt32();
          break;
        }
        case 504: {
          DropCoefficientInEliteRoom = input.ReadInt32();
          break;
        }
        case 512: {
          DropCoefficientInBossRoom = input.ReadInt32();
          break;
        }
        case 520: {
          HeroRebornTime = input.ReadInt32();
          break;
        }
        case 528: {
          HeroRebornHpCostFactor = input.ReadInt32();
          break;
        }
        case 536: {
          OriginalHandCardNum = input.ReadInt32();
          break;
        }
        case 544: {
          ChallengeFirstHandChance = input.ReadInt32();
          break;
        }
        case 552: {
          PvpChallengeTime = input.ReadInt32();
          break;
        }
        case 560: {
          FirstHandEnergyCardCount = input.ReadInt32();
          break;
        }
        case 568: {
          SecondtHandEnergyCardCount = input.ReadInt32();
          break;
        }
        case 576: {
          PvpFirstHandTime = input.ReadInt32();
          break;
        }
        case 584: {
          PvpSecondHandTime = input.ReadInt32();
          break;
        }
        case 592: {
          LordCardSpacing = input.ReadInt32();
          break;
        }
        case 600: {
          EnergyCardCheckUp = input.ReadInt32();
          break;
        }
        case 608: {
          PvpOriginalHandCardNum = input.ReadInt32();
          break;
        }
        case 618:
        case 617: {
          battleSpeedUpRates_.AddEntriesFrom(input, _repeated_battleSpeedUpRates_codec);
          break;
        }
        case 624: {
          HangUpIntervalTime = input.ReadInt32();
          break;
        }
        case 632: {
          NextWaveAppearInterval = input.ReadInt32();
          break;
        }
        case 642: {
          if (dice_ == null) {
            Dice = new global::BattleParam.Types.Dice_();
          }
          input.ReadMessage(Dice);
          break;
        }
        case 648: {
          RemainsCompoundOriginalCount = input.ReadInt32();
          break;
        }
        case 658: {
          if (mazeValueFactor_ == null) {
            MazeValueFactor = new global::BattleParam.Types.Mazevaluefactor_();
          }
          input.ReadMessage(MazeValueFactor);
          break;
        }
        case 664: {
          BattleDashTime = input.ReadInt32();
          break;
        }
        case 672: {
          BattleDashBackTime = input.ReadInt32();
          break;
        }
        case 680: {
          BattleRoundSafeTime = input.ReadInt32();
          break;
        }
        case 688: {
          BattleWaitNextTime = input.ReadInt32();
          break;
        }
        case 696: {
          BattleRoundTime = input.ReadInt32();
          break;
        }
        case 704: {
          BattleHitFlyForce = input.ReadInt32();
          break;
        }
        case 712: {
          BattleHitDownForce = input.ReadInt32();
          break;
        }
        case 720: {
          BattleHitFlyMaxHeight = input.ReadInt32();
          break;
        }
        case 728: {
          BattleGravity = input.ReadInt32();
          break;
        }
        case 736: {
          BattleFlyUpGravity = input.ReadInt32();
          break;
        }
        case 744: {
          BattleNearTopGravity = input.ReadInt32();
          break;
        }
        case 752: {
          BattleNearTopSpeed = input.ReadInt32();
          break;
        }
      }
    }
  #endif
  }

  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
          break;
        case 8: {
          BattleStartWaitTime = input.ReadInt32();
          break;
        }
        case 18:
        case 16: {
          battleMapSizes_.AddEntriesFrom(ref input, _repeated_battleMapSizes_codec);
          break;
        }
        case 26: {
          if (dodgeEffectLimit_ == null) {
            DodgeEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(DodgeEffectLimit);
          break;
        }
        case 34: {
          if (critEffectLimit_ == null) {
            CritEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(CritEffectLimit);
          break;
        }
        case 42: {
          if (critDamEffectLimit_ == null) {
            CritDamEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(CritDamEffectLimit);
          break;
        }
        case 50: {
          if (defenseRateEffectLimit_ == null) {
            DefenseRateEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(DefenseRateEffectLimit);
          break;
        }
        case 56: {
          DamageReduceLimit = input.ReadInt32();
          break;
        }
        case 66: {
          if (coolDownLimit_ == null) {
            CoolDownLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(CoolDownLimit);
          break;
        }
        case 74: {
          if (elementEffectLimit_ == null) {
            ElementEffectLimit = new global::BattleParam.Types.Elementeffectlimit_();
          }
          input.ReadMessage(ElementEffectLimit);
          break;
        }
        case 81: {
          ElementAttackBase = input.ReadDouble();
          break;
        }
        case 89: {
          ElementDefenseBase = input.ReadDouble();
          break;
        }
        case 96: {
          ElementEffectBase = input.ReadInt32();
          break;
        }
        case 106: {
          if (damageCorrectionRange_ == null) {
            DamageCorrectionRange = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(DamageCorrectionRange);
          break;
        }
        case 113: {
          DodgeCorrection = input.ReadDouble();
          break;
        }
        case 121: {
          CritCorrection = input.ReadDouble();
          break;
        }
        case 128: {
          BlckEffect = input.ReadInt32();
          break;
        }
        case 138: {
          if (blockEffectLimit_ == null) {
            BlockEffectLimit = new global::BattleParam.Types.Dodgeeffectlimit_();
          }
          input.ReadMessage(BlockEffectLimit);
          break;
        }
        case 144: {
          HeroMaxEnergyValue = input.ReadInt32();
          break;
        }
        case 152: {
          HeroMaxEnergyNum = input.ReadInt32();
          break;
        }
        case 160: {
          LordMaxEnergy = input.ReadInt32();
          break;
        }
        case 169: {
          MaxAttackSpeed = input.ReadDouble();
          break;
        }
        case 176: {
          HeroSkillCount = input.ReadInt32();
          break;
        }
        case 184: {
          MonsterWalkModeTime = input.ReadInt32();
          break;
        }
        case 192: {
          MonsterDropModeTime = input.ReadInt32();
          break;
        }
        case 202: {
          if (battleMapGrid_ == null) {
            BattleMapGrid = new global::Position3Int();
          }
          input.ReadMessage(BattleMapGrid);
          break;
        }
        case 208: {
          GridSize = input.ReadInt32();
          break;
        }
        case 216: {
          LordGrid = input.ReadInt32();
          break;
        }
        case 224: {
          SkillMoveTime = input.ReadInt32();
          break;
        }
        case 232: {
          SkillFlashTime = input.ReadInt32();
          break;
        }
        case 240: {
          MonsterDropRange = input.ReadInt32();
          break;
        }
        case 248: {
          OffsetDistance = input.ReadInt32();
          break;
        }
        case 256: {
          DropItemStayTime = input.ReadInt32();
          break;
        }
        case 264: {
          BannerStayMaxtime = input.ReadInt32();
          break;
        }
        case 272: {
          LordMoveSpeed = input.ReadInt32();
          break;
        }
        case 280: {
          DropItemRange = input.ReadInt32();
          break;
        }
        case 288: {
          MaxRoom = input.ReadInt32();
          break;
        }
        case 296: {
          LordHealthFactor = input.ReadInt32();
          break;
        }
        case 306:
        case 304: {
          runeRefreshPrices_.AddEntriesFrom(ref input, _repeated_runeRefreshPrices_codec);
          break;
        }
        case 312: {
          HeroMaxRuneCount = input.ReadInt32();
          break;
        }
        case 320: {
          MaxSoulStampDemand = input.ReadInt32();
          break;
        }
        case 329: {
          SoulStampDemandFactor = input.ReadDouble();
          break;
        }
        case 336: {
          BagCapacity = input.ReadInt32();
          break;
        }
        case 344: {
          ResolveFactor = input.ReadInt32();
          break;
        }
        case 352: {
          SkillFadeOutTime = input.ReadInt32();
          break;
        }
        case 360: {
          PvpEnemyLordGrid = input.ReadInt32();
          break;
        }
        case 370:
        case 368: {
          pvpSceneBuffs_.AddEntriesFrom(ref input, _repeated_pvpSceneBuffs_codec);
          break;
        }
        case 376: {
          PvpFirstHandWaiting = input.ReadInt32();
          break;
        }
        case 384: {
          PvpSecondHandWaiting = input.ReadInt32();
          break;
        }
        case 392: {
          PvpStartCountDown = input.ReadInt32();
          break;
        }
        case 400: {
          PvpOverCountDown = input.ReadInt32();
          break;
        }
        case 410: {
          if (soulInterest_ == null) {
            SoulInterest = new global::BattleParam.Types.Soulinterest_();
          }
          input.ReadMessage(SoulInterest);
          break;
        }
        case 416: {
          BattleHeroDieValue = input.ReadInt32();
          break;
        }
        case 424: {
          BattleMaxTimeValue = input.ReadInt32();
          break;
        }
        case 432: {
          BattleJumpTime = input.ReadInt32();
          break;
        }
        case 440: {
          ProfessionUpgradeCount = input.ReadInt32();
          break;
        }
        case 448: {
          HandCardLimit = input.ReadInt32();
          break;
        }
        case 458:
        case 456: {
          forgetCosts_.AddEntriesFrom(ref input, _repeated_forgetCosts_codec);
          break;
        }
        case 466:
        case 464: {
          prayCosts_.AddEntriesFrom(ref input, _repeated_prayCosts_codec);
          break;
        }
        case 472: {
          CardLevelUpNeedNum = input.ReadInt32();
          break;
        }
        case 480: {
          CardUseToDrawUnique = input.ReadInt32();
          break;
        }
        case 488: {
          OriginalHandCardLimit = input.ReadInt32();
          break;
        }
        case 496: {
          UniqueSkillCardLimitCountOT = input.ReadInt32();
          break;
        }
        case 504: {
          DropCoefficientInEliteRoom = input.ReadInt32();
          break;
        }
        case 512: {
          DropCoefficientInBossRoom = input.ReadInt32();
          break;
        }
        case 520: {
          HeroRebornTime = input.ReadInt32();
          break;
        }
        case 528: {
          HeroRebornHpCostFactor = input.ReadInt32();
          break;
        }
        case 536: {
          OriginalHandCardNum = input.ReadInt32();
          break;
        }
        case 544: {
          ChallengeFirstHandChance = input.ReadInt32();
          break;
        }
        case 552: {
          PvpChallengeTime = input.ReadInt32();
          break;
        }
        case 560: {
          FirstHandEnergyCardCount = input.ReadInt32();
          break;
        }
        case 568: {
          SecondtHandEnergyCardCount = input.ReadInt32();
          break;
        }
        case 576: {
          PvpFirstHandTime = input.ReadInt32();
          break;
        }
        case 584: {
          PvpSecondHandTime = input.ReadInt32();
          break;
        }
        case 592: {
          LordCardSpacing = input.ReadInt32();
          break;
        }
        case 600: {
          EnergyCardCheckUp = input.ReadInt32();
          break;
        }
        case 608: {
          PvpOriginalHandCardNum = input.ReadInt32();
          break;
        }
        case 618:
        case 617: {
          battleSpeedUpRates_.AddEntriesFrom(ref input, _repeated_battleSpeedUpRates_codec);
          break;
        }
        case 624: {
          HangUpIntervalTime = input.ReadInt32();
          break;
        }
        case 632: {
          NextWaveAppearInterval = input.ReadInt32();
          break;
        }
        case 642: {
          if (dice_ == null) {
            Dice = new global::BattleParam.Types.Dice_();
          }
          input.ReadMessage(Dice);
          break;
        }
        case 648: {
          RemainsCompoundOriginalCount = input.ReadInt32();
          break;
        }
        case 658: {
          if (mazeValueFactor_ == null) {
            MazeValueFactor = new global::BattleParam.Types.Mazevaluefactor_();
          }
          input.ReadMessage(MazeValueFactor);
          break;
        }
        case 664: {
          BattleDashTime = input.ReadInt32();
          break;
        }
        case 672: {
          BattleDashBackTime = input.ReadInt32();
          break;
        }
        case 680: {
          BattleRoundSafeTime = input.ReadInt32();
          break;
        }
        case 688: {
          BattleWaitNextTime = input.ReadInt32();
          break;
        }
        case 696: {
          BattleRoundTime = input.ReadInt32();
          break;
        }
        case 704: {
          BattleHitFlyForce = input.ReadInt32();
          break;
        }
        case 712: {
          BattleHitDownForce = input.ReadInt32();
          break;
        }
        case 720: {
          BattleHitFlyMaxHeight = input.ReadInt32();
          break;
        }
        case 728: {
          BattleGravity = input.ReadInt32();
          break;
        }
        case 736: {
          BattleFlyUpGravity = input.ReadInt32();
          break;
        }
        case 744: {
          BattleNearTopGravity = input.ReadInt32();
          break;
        }
        case 752: {
          BattleNearTopSpeed = input.ReadInt32();
          break;
        }
      }
    }
  }
  #endif

  #region Nested types
  /// <summary>Container for nested types declared in the BattleParam message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types {
    public sealed partial class Dodgeeffectlimit_ : pb::IMessage<Dodgeeffectlimit_>
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        , pb::IBufferMessage
    #endif
    {
      private static readonly pb::MessageParser<Dodgeeffectlimit_> _parser = new pb::MessageParser<Dodgeeffectlimit_>(() => new Dodgeeffectlimit_());
      private pb::UnknownFieldSet _unknownFields;
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pb::MessageParser<Dodgeeffectlimit_> Parser { get { return _parser; } }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pbr::MessageDescriptor Descriptor {
        get { return global::BattleParam.Descriptor.NestedTypes[0]; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Dodgeeffectlimit_() {
        OnConstruction();
      }

      partial void OnConstruction();

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Dodgeeffectlimit_(Dodgeeffectlimit_ other) : this() {
        max_ = other.max_;
        min_ = other.min_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Dodgeeffectlimit_ Clone() {
        return new Dodgeeffectlimit_(this);
      }

      /// <summary>Field number for the "Max" field.</summary>
      public const int MaxFieldNumber = 1;
      private int max_;
      /// <summary>
      /// Max
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int Max {
        get { return max_; }
        set {
          max_ = value;
        }
      }

      /// <summary>Field number for the "Min" field.</summary>
      public const int MinFieldNumber = 2;
      private int min_;
      /// <summary>
      /// Min
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int Min {
        get { return min_; }
        set {
          min_ = value;
        }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override bool Equals(object other) {
        return Equals(other as Dodgeeffectlimit_);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public bool Equals(Dodgeeffectlimit_ other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Max != other.Max) return false;
        if (Min != other.Min) return false;
        return Equals(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override int GetHashCode() {
        int hash = 1;
        if (Max != 0) hash ^= Max.GetHashCode();
        if (Min != 0) hash ^= Min.GetHashCode();
        if (_unknownFields != null) {
          hash ^= _unknownFields.GetHashCode();
        }
        return hash;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override string ToString() {
        return pb::JsonFormatter.ToDiagnosticString(this);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void WriteTo(pb::CodedOutputStream output) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
      #else
        if (Max != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Max);
        }
        if (Min != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(Min);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(output);
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
        if (Max != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Max);
        }
        if (Min != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(Min);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(ref output);
        }
      }
      #endif

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int CalculateSize() {
        int size = 0;
        if (Max != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Max);
        }
        if (Min != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Min);
        }
        if (_unknownFields != null) {
          size += _unknownFields.CalculateSize();
        }
        return size;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(Dodgeeffectlimit_ other) {
        if (other == null) {
          return;
        }
        if (other.Max != 0) {
          Max = other.Max;
        }
        if (other.Min != 0) {
          Min = other.Min;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(pb::CodedInputStream input) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
      #else
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
              break;
            case 8: {
              Max = input.ReadInt32();
              break;
            }
            case 16: {
              Min = input.ReadInt32();
              break;
            }
          }
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
              break;
            case 8: {
              Max = input.ReadInt32();
              break;
            }
            case 16: {
              Min = input.ReadInt32();
              break;
            }
          }
        }
      }
      #endif

    }

    public sealed partial class Elementeffectlimit_ : pb::IMessage<Elementeffectlimit_>
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        , pb::IBufferMessage
    #endif
    {
      private static readonly pb::MessageParser<Elementeffectlimit_> _parser = new pb::MessageParser<Elementeffectlimit_>(() => new Elementeffectlimit_());
      private pb::UnknownFieldSet _unknownFields;
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pb::MessageParser<Elementeffectlimit_> Parser { get { return _parser; } }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pbr::MessageDescriptor Descriptor {
        get { return global::BattleParam.Descriptor.NestedTypes[1]; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Elementeffectlimit_() {
        OnConstruction();
      }

      partial void OnConstruction();

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Elementeffectlimit_(Elementeffectlimit_ other) : this() {
        max_ = other.max_;
        min_ = other.min_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Elementeffectlimit_ Clone() {
        return new Elementeffectlimit_(this);
      }

      /// <summary>Field number for the "Max" field.</summary>
      public const int MaxFieldNumber = 1;
      private double max_;
      /// <summary>
      /// Max
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public double Max {
        get { return max_; }
        set {
          max_ = value;
        }
      }

      /// <summary>Field number for the "Min" field.</summary>
      public const int MinFieldNumber = 2;
      private double min_;
      /// <summary>
      /// Min
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public double Min {
        get { return min_; }
        set {
          min_ = value;
        }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override bool Equals(object other) {
        return Equals(other as Elementeffectlimit_);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public bool Equals(Elementeffectlimit_ other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Max, other.Max)) return false;
        if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Min, other.Min)) return false;
        return Equals(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override int GetHashCode() {
        int hash = 1;
        if (Max != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Max);
        if (Min != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Min);
        if (_unknownFields != null) {
          hash ^= _unknownFields.GetHashCode();
        }
        return hash;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override string ToString() {
        return pb::JsonFormatter.ToDiagnosticString(this);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void WriteTo(pb::CodedOutputStream output) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
      #else
        if (Max != 0D) {
          output.WriteRawTag(9);
          output.WriteDouble(Max);
        }
        if (Min != 0D) {
          output.WriteRawTag(17);
          output.WriteDouble(Min);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(output);
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
        if (Max != 0D) {
          output.WriteRawTag(9);
          output.WriteDouble(Max);
        }
        if (Min != 0D) {
          output.WriteRawTag(17);
          output.WriteDouble(Min);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(ref output);
        }
      }
      #endif

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int CalculateSize() {
        int size = 0;
        if (Max != 0D) {
          size += 1 + 8;
        }
        if (Min != 0D) {
          size += 1 + 8;
        }
        if (_unknownFields != null) {
          size += _unknownFields.CalculateSize();
        }
        return size;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(Elementeffectlimit_ other) {
        if (other == null) {
          return;
        }
        if (other.Max != 0D) {
          Max = other.Max;
        }
        if (other.Min != 0D) {
          Min = other.Min;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(pb::CodedInputStream input) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
      #else
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
              break;
            case 9: {
              Max = input.ReadDouble();
              break;
            }
            case 17: {
              Min = input.ReadDouble();
              break;
            }
          }
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
              break;
            case 9: {
              Max = input.ReadDouble();
              break;
            }
            case 17: {
              Min = input.ReadDouble();
              break;
            }
          }
        }
      }
      #endif

    }

    public sealed partial class Soulinterest_ : pb::IMessage<Soulinterest_>
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        , pb::IBufferMessage
    #endif
    {
      private static readonly pb::MessageParser<Soulinterest_> _parser = new pb::MessageParser<Soulinterest_>(() => new Soulinterest_());
      private pb::UnknownFieldSet _unknownFields;
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pb::MessageParser<Soulinterest_> Parser { get { return _parser; } }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pbr::MessageDescriptor Descriptor {
        get { return global::BattleParam.Descriptor.NestedTypes[2]; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Soulinterest_() {
        OnConstruction();
      }

      partial void OnConstruction();

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Soulinterest_(Soulinterest_ other) : this() {
        factor_ = other.factor_;
        maxCount_ = other.maxCount_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Soulinterest_ Clone() {
        return new Soulinterest_(this);
      }

      /// <summary>Field number for the "Factor" field.</summary>
      public const int FactorFieldNumber = 1;
      private int factor_;
      /// <summary>
      /// Factor
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int Factor {
        get { return factor_; }
        set {
          factor_ = value;
        }
      }

      /// <summary>Field number for the "MaxCount" field.</summary>
      public const int MaxCountFieldNumber = 2;
      private int maxCount_;
      /// <summary>
      /// MaxCount
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int MaxCount {
        get { return maxCount_; }
        set {
          maxCount_ = value;
        }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override bool Equals(object other) {
        return Equals(other as Soulinterest_);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public bool Equals(Soulinterest_ other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Factor != other.Factor) return false;
        if (MaxCount != other.MaxCount) return false;
        return Equals(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override int GetHashCode() {
        int hash = 1;
        if (Factor != 0) hash ^= Factor.GetHashCode();
        if (MaxCount != 0) hash ^= MaxCount.GetHashCode();
        if (_unknownFields != null) {
          hash ^= _unknownFields.GetHashCode();
        }
        return hash;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override string ToString() {
        return pb::JsonFormatter.ToDiagnosticString(this);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void WriteTo(pb::CodedOutputStream output) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
      #else
        if (Factor != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Factor);
        }
        if (MaxCount != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(MaxCount);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(output);
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
        if (Factor != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Factor);
        }
        if (MaxCount != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(MaxCount);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(ref output);
        }
      }
      #endif

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int CalculateSize() {
        int size = 0;
        if (Factor != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Factor);
        }
        if (MaxCount != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxCount);
        }
        if (_unknownFields != null) {
          size += _unknownFields.CalculateSize();
        }
        return size;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(Soulinterest_ other) {
        if (other == null) {
          return;
        }
        if (other.Factor != 0) {
          Factor = other.Factor;
        }
        if (other.MaxCount != 0) {
          MaxCount = other.MaxCount;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(pb::CodedInputStream input) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
      #else
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
              break;
            case 8: {
              Factor = input.ReadInt32();
              break;
            }
            case 16: {
              MaxCount = input.ReadInt32();
              break;
            }
          }
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
              break;
            case 8: {
              Factor = input.ReadInt32();
              break;
            }
            case 16: {
              MaxCount = input.ReadInt32();
              break;
            }
          }
        }
      }
      #endif

    }

    public sealed partial class Dice_ : pb::IMessage<Dice_>
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        , pb::IBufferMessage
    #endif
    {
      private static readonly pb::MessageParser<Dice_> _parser = new pb::MessageParser<Dice_>(() => new Dice_());
      private pb::UnknownFieldSet _unknownFields;
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pb::MessageParser<Dice_> Parser { get { return _parser; } }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pbr::MessageDescriptor Descriptor {
        get { return global::BattleParam.Descriptor.NestedTypes[3]; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Dice_() {
        OnConstruction();
      }

      partial void OnConstruction();

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Dice_(Dice_ other) : this() {
        diceCount_ = other.diceCount_;
        diceValue_ = other.diceValue_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Dice_ Clone() {
        return new Dice_(this);
      }

      /// <summary>Field number for the "DiceCount" field.</summary>
      public const int DiceCountFieldNumber = 1;
      private int diceCount_;
      /// <summary>
      /// DiceCount
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int DiceCount {
        get { return diceCount_; }
        set {
          diceCount_ = value;
        }
      }

      /// <summary>Field number for the "DiceValue" field.</summary>
      public const int DiceValueFieldNumber = 2;
      private int diceValue_;
      /// <summary>
      /// DiceValue
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int DiceValue {
        get { return diceValue_; }
        set {
          diceValue_ = value;
        }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override bool Equals(object other) {
        return Equals(other as Dice_);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public bool Equals(Dice_ other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (DiceCount != other.DiceCount) return false;
        if (DiceValue != other.DiceValue) return false;
        return Equals(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override int GetHashCode() {
        int hash = 1;
        if (DiceCount != 0) hash ^= DiceCount.GetHashCode();
        if (DiceValue != 0) hash ^= DiceValue.GetHashCode();
        if (_unknownFields != null) {
          hash ^= _unknownFields.GetHashCode();
        }
        return hash;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override string ToString() {
        return pb::JsonFormatter.ToDiagnosticString(this);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void WriteTo(pb::CodedOutputStream output) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
      #else
        if (DiceCount != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(DiceCount);
        }
        if (DiceValue != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(DiceValue);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(output);
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
        if (DiceCount != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(DiceCount);
        }
        if (DiceValue != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(DiceValue);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(ref output);
        }
      }
      #endif

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int CalculateSize() {
        int size = 0;
        if (DiceCount != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(DiceCount);
        }
        if (DiceValue != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(DiceValue);
        }
        if (_unknownFields != null) {
          size += _unknownFields.CalculateSize();
        }
        return size;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(Dice_ other) {
        if (other == null) {
          return;
        }
        if (other.DiceCount != 0) {
          DiceCount = other.DiceCount;
        }
        if (other.DiceValue != 0) {
          DiceValue = other.DiceValue;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(pb::CodedInputStream input) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
      #else
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
              break;
            case 8: {
              DiceCount = input.ReadInt32();
              break;
            }
            case 16: {
              DiceValue = input.ReadInt32();
              break;
            }
          }
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
              break;
            case 8: {
              DiceCount = input.ReadInt32();
              break;
            }
            case 16: {
              DiceValue = input.ReadInt32();
              break;
            }
          }
        }
      }
      #endif

    }

    public sealed partial class Mazevaluefactor_ : pb::IMessage<Mazevaluefactor_>
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        , pb::IBufferMessage
    #endif
    {
      private static readonly pb::MessageParser<Mazevaluefactor_> _parser = new pb::MessageParser<Mazevaluefactor_>(() => new Mazevaluefactor_());
      private pb::UnknownFieldSet _unknownFields;
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pb::MessageParser<Mazevaluefactor_> Parser { get { return _parser; } }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public static pbr::MessageDescriptor Descriptor {
        get { return global::BattleParam.Descriptor.NestedTypes[4]; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Mazevaluefactor_() {
        OnConstruction();
      }

      partial void OnConstruction();

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Mazevaluefactor_(Mazevaluefactor_ other) : this() {
        atkRate_ = other.atkRate_;
        factor_ = other.factor_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public Mazevaluefactor_ Clone() {
        return new Mazevaluefactor_(this);
      }

      /// <summary>Field number for the "AtkRate" field.</summary>
      public const int AtkRateFieldNumber = 1;
      private double atkRate_;
      /// <summary>
      /// AtkRate
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public double AtkRate {
        get { return atkRate_; }
        set {
          atkRate_ = value;
        }
      }

      /// <summary>Field number for the "Factor" field.</summary>
      public const int FactorFieldNumber = 2;
      private int factor_;
      /// <summary>
      /// Factor
      /// </summary>
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int Factor {
        get { return factor_; }
        set {
          factor_ = value;
        }
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override bool Equals(object other) {
        return Equals(other as Mazevaluefactor_);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public bool Equals(Mazevaluefactor_ other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AtkRate, other.AtkRate)) return false;
        if (Factor != other.Factor) return false;
        return Equals(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override int GetHashCode() {
        int hash = 1;
        if (AtkRate != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AtkRate);
        if (Factor != 0) hash ^= Factor.GetHashCode();
        if (_unknownFields != null) {
          hash ^= _unknownFields.GetHashCode();
        }
        return hash;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public override string ToString() {
        return pb::JsonFormatter.ToDiagnosticString(this);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void WriteTo(pb::CodedOutputStream output) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
      #else
        if (AtkRate != 0D) {
          output.WriteRawTag(9);
          output.WriteDouble(AtkRate);
        }
        if (Factor != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(Factor);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(output);
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
        if (AtkRate != 0D) {
          output.WriteRawTag(9);
          output.WriteDouble(AtkRate);
        }
        if (Factor != 0) {
          output.WriteRawTag(16);
          output.WriteInt32(Factor);
        }
        if (_unknownFields != null) {
          _unknownFields.WriteTo(ref output);
        }
      }
      #endif

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public int CalculateSize() {
        int size = 0;
        if (AtkRate != 0D) {
          size += 1 + 8;
        }
        if (Factor != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Factor);
        }
        if (_unknownFields != null) {
          size += _unknownFields.CalculateSize();
        }
        return size;
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(Mazevaluefactor_ other) {
        if (other == null) {
          return;
        }
        if (other.AtkRate != 0D) {
          AtkRate = other.AtkRate;
        }
        if (other.Factor != 0) {
          Factor = other.Factor;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      public void MergeFrom(pb::CodedInputStream input) {
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
      #else
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
              break;
            case 9: {
              AtkRate = input.ReadDouble();
              break;
            }
            case 16: {
              Factor = input.ReadInt32();
              break;
            }
          }
        }
      #endif
      }

      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
              break;
            case 9: {
              AtkRate = input.ReadDouble();
              break;
            }
            case 16: {
              Factor = input.ReadInt32();
              break;
            }
          }
        }
      }
      #endif

    }

  }
  #endregion

}

#endregion


#endregion Designer generated code
